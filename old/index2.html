<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>NeuroWeaver ðŸ§  v2</title>
    <link href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ§ </text></svg>"
          rel="icon">
    <style>
        :root {
            --bg-color: #000000;
            --dot-color: rgba(100, 100, 120, 0.2);
            --primary-color: #e0e0f0;
            --accent-color: #00d0ff;
            --accent-color-darker: #008ea8;
            --node-bg-default: rgba(15, 15, 35, 0.85);
            --node-border: var(--accent-color-darker);
            --node-shadow: rgba(0, 208, 255, 0.1);
            --node-hover-shadow: rgba(0, 208, 255, 0.3);
            --node-selected-shadow: rgba(0, 208, 255, 0.5);
            --edge-color: rgba(0, 208, 255, 0.5);
            --edge-highlight-color: #00ffff;
            --delete-button-bg: #d03030;
            --delete-button-text: #ffffff;
            --menu-bg: rgba(20, 20, 40, 0.95);
            --menu-border: var(--accent-color);
            --menu-hover-bg: rgba(0, 208, 255, 0.15);
            --dialog-bg: rgba(25, 25, 50, 0.98);
            --font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            --font-mono: 'Fira Code', 'Consolas', 'Monaco', monospace;
            --transition-fast: 0.15s ease-out;
            --transition-med: 0.3s ease-out;
            --node-button-bg: rgba(255, 255, 255, 0.1);
            --node-button-hover-bg: rgba(0, 208, 255, 0.3);
        }

        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--primary-color);
            font-family: var(--font-family);
            font-size: 14px;
            overscroll-behavior: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-image: radial-gradient(var(--dot-color) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #mindmap-container {
            position: fixed;
            inset: 0;
            cursor: grab;
        }

        #mindmap-container.panning {
            cursor: grabbing;
        }

        #mindmap-container.linking {
            cursor: crosshair;
        }

        #webgl-canvas, #css3d-container {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        #webgl-canvas {
            z-index: 1;
        }

        #css3d-container {
            z-index: 2;
            pointer-events: none;
        }

        .node-html {
            position: absolute;
            background-color: var(--node-bg, var(--node-bg-default));
            border: 1px solid var(--node-border);
            border-radius: 8px;
            padding: 0; /* Padding handled by inner container */
            color: var(--primary-color);
            pointer-events: auto;
            cursor: grab;
            transition: transform var(--transition-fast), box-shadow var(--transition-med), border-color var(--transition-med);
            box-shadow: 0 2px 8px 1px var(--node-shadow);
            min-width: 80px;
            min-height: 40px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            backdrop-filter: blur(6px);
            user-select: none;
        }

        .node-html:hover {
            box-shadow: 0 4px 15px 3px var(--node-hover-shadow);
            border-color: var(--accent-color);
            z-index: 10 !important;
        }

        .node-html.selected {
            box-shadow: 0 0 20px 5px var(--node-selected-shadow);
            border-color: var(--accent-color);
            z-index: 11 !important; /* Slightly higher than hover */
        }

        .node-html.dragging {
            cursor: grabbing;
            box-shadow: 0 8px 25px 6px var(--node-hover-shadow);
            z-index: 1000 !important;
            transition: none;
        }

        .node-html.resizing {
            transition: none;
        }

        .node-html.linking-target {
            border-color: #ffaa00;
            box-shadow: 0 0 20px 5px rgba(255, 170, 0, 0.5);
        }

        .node-inner-wrapper {
            padding: 12px 15px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Clip content */
            position: relative; /* For absolute positioning of controls */
        }

        .node-content {
            flex-grow: 1;
            outline: none;
            overflow-y: auto;
            max-height: 400px;
            font-size: 1em; /* Base size, scaled by contentZoom */
            line-height: 1.45;
            white-space: pre-wrap;
            word-wrap: break-word;
            user-select: text;
            scrollbar-width: thin;
            scrollbar-color: var(--accent-color-darker) transparent;
            transition: transform var(--transition-fast); /* For content zoom */
            transform-origin: top left;
        }

        .node-content::-webkit-scrollbar {
            width: 6px;
        }

        .node-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .node-content::-webkit-scrollbar-thumb {
            background-color: var(--accent-color-darker);
            border-radius: 3px;
        }

        .node-content:focus {
            box-shadow: inset 0 0 0 1px var(--accent-color);
            margin: -1px;
        }

        .node-content > *:first-child {
            margin-top: 0;
        }

        .node-content > *:last-child {
            margin-bottom: 0;
        }

        .node-content h1, .node-content h2, .node-content h3 {
            margin: 0.5em 0;
            color: var(--accent-color);
            font-weight: 600;
        }

        .node-content h1 {
            font-size: 1.3em;
        }

        .node-content h2 {
            font-size: 1.15em;
        }

        .node-content h3 {
            font-size: 1.05em;
        }

        .node-content p {
            margin: 0.5em 0;
        }

        .node-content ul, .node-content ol {
            margin: 0.5em 0;
            padding-left: 20px;
        }

        .node-content li {
            margin-bottom: 0.2em;
        }

        .node-content code {
            font-family: var(--font-mono);
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0.1em 0.3em;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .node-content pre {
            font-family: var(--font-mono);
            background-color: rgba(0, 0, 0, 0.2);
            padding: 0.5em;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 0.9em;
        }

        .node-content blockquote {
            border-left: 3px solid var(--accent-color-darker);
            margin: 0.5em 0 0.5em 10px;
            padding-left: 10px;
            color: #bbb;
        }

        .node-content a {
            color: var(--accent-color);
            text-decoration: none;
        }

        .node-content a:hover {
            text-decoration: underline;
        }

        .node-content button, .node-content input {
            pointer-events: auto; /* Allow interaction with form elements */
            margin: 5px;
            padding: 5px 10px;
            background-color: var(--accent-color-darker);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .node-content input[type="range"] {
            padding: 0;
        }

        .node-content button:hover {
            background-color: var(--accent-color);
        }

        .node-controls {
            position: absolute;
            top: 4px;
            right: 4px;
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity var(--transition-fast);
            pointer-events: none; /* Allow clicks through initially */
        }

        .node-html:hover .node-controls,
        .node-html.selected .node-controls {
            opacity: 0.9;
            pointer-events: auto;
        }

        .node-quick-button {
            background-color: var(--node-button-bg);
            color: var(--primary-color);
            border: none;
            border-radius: 4px;
            width: 22px;
            height: 22px;
            font-size: 14px;
            line-height: 22px;
            text-align: center;
            cursor: pointer;
            transition: background-color var(--transition-fast), transform var(--transition-fast);
        }

        .node-quick-button:hover {
            background-color: var(--node-button-hover-bg);
            transform: scale(1.1);
        }

        .node-quick-button.delete-button {
            background-color: var(--delete-button-bg);
            color: var(--delete-button-text);
            font-weight: bold;
        }

        .node-quick-button.delete-button:hover {
            background-color: #ff5555;
        }

        .resize-handle {
            position: absolute;
            bottom: -1px;
            right: -1px; /* Align with bottom-right border */
            width: 16px;
            height: 16px;
            background-color: var(--accent-color);
            border-top: 1px solid var(--bg-color);
            border-left: 1px solid var(--bg-color);
            border-bottom-right-radius: 7px; /* Match node radius */
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity var(--transition-fast), transform var(--transition-fast);
            pointer-events: auto;
            z-index: 10;
        }

        .node-html:hover .resize-handle,
        .node-html.selected .resize-handle {
            opacity: 0.7;
        }

        /* Show on selected too */
        .resize-handle:hover {
            opacity: 1;
            transform: scale(1.15);
        }

        .context-menu, .dialog {
            position: fixed;
            background-color: var(--menu-bg);
            border: 1px solid var(--menu-border);
            border-radius: 6px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.6);
            z-index: 10000;
            display: none;
            backdrop-filter: blur(8px);
            animation: fadeIn 0.1s ease-out forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .context-menu {
            padding: 6px 0;
            min-width: 180px;
        }

        .context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .context-menu li {
            padding: 8px 18px;
            cursor: pointer;
            transition: background-color var(--transition-fast), color var(--transition-fast);
            color: var(--primary-color);
            white-space: nowrap;
        }

        .context-menu li:hover {
            background-color: var(--menu-hover-bg);
            color: var(--accent-color);
        }

        .context-menu li.separator {
            height: 1px;
            background-color: var(--accent-color-darker);
            margin: 5px 0;
            padding: 0;
            cursor: default;
        }

        .context-menu li.separator:hover {
            background-color: var(--accent-color-darker);
        }

        .context-menu li[data-action^="delete"] {
            color: var(--delete-button-bg);
        }

        .context-menu li[data-action^="delete"]:hover {
            background-color: rgba(208, 48, 48, 0.2);
        }

        .dialog {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--dialog-bg);
            padding: 25px 30px;
            text-align: center;
            color: var(--primary-color);
            min-width: 300px;
        }

        .dialog p {
            margin: 0 0 25px 0;
            font-size: 1.1em;
        }

        .dialog button {
            background-color: var(--accent-color);
            color: var(--bg-color);
            border: none;
            padding: 10px 22px;
            margin: 0 10px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color var(--transition-fast), box-shadow var(--transition-fast);
            min-width: 80px;
        }

        .dialog button:hover {
            background-color: #3fffff;
            box-shadow: 0 0 12px var(--accent-color);
        }

        .dialog button#confirm-no {
            background-color: #555;
            color: var(--primary-color);
        }

        .dialog button#confirm-no:hover {
            background-color: #777;
            box-shadow: none;
        }

        #status-indicator {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: var(--primary-color);
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 5;
            opacity: 1;
            transition: opacity 0.5s ease 1s;
            pointer-events: none;
        }

        #status-indicator.hidden {
            opacity: 0;
        }

        .edge-menu-frame { /* Style for edge menu if implemented as HTML */
            position: absolute;
            background: var(--menu-bg);
            border: 1px solid var(--accent-color);
            border-radius: 4px;
            padding: 4px;
            display: flex;
            gap: 3px;
            pointer-events: auto;
            z-index: 100;
            opacity: 0.9;
            transition: opacity 0.1s;
        }

        .edge-menu-frame button {
            background: var(--node-button-bg);
            color: var(--primary-color);
            border: none;
            border-radius: 3px;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 20px;
            text-align: center;
            cursor: pointer;
        }

        .edge-menu-frame button:hover {
            background: var(--node-button-hover-bg);
        }

        .edge-menu-frame button.delete {
            background-color: var(--delete-button-bg);
            color: var(--delete-button-text);
        }

    </style>
</head>
<body>
<div id="mindmap-container">
    <canvas id="webgl-canvas"></canvas>
    <div id="css3d-container"></div>
</div>

<div class="context-menu" id="context-menu"></div>
<div class="dialog" id="confirm-dialog">
    <p id="confirm-message">Are you sure?</p>
    <button id="confirm-yes">Yes</button>
    <button id="confirm-no">No</button>
</div>
<div id="status-indicator">Initializing NeuroWeaver...</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
            "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import {CSS3DRenderer, CSS3DObject} from 'three/addons/renderers/CSS3DRenderer.js';
    import {gsap} from "gsap";

    const $ = (selector) => document.querySelector(selector);
    const $$ = (selector) => document.querySelectorAll(selector);

    const clamp = (val, min, max) => Math.max(min, Math.min(max, val));
    const lerp = (a, b, t) => a + (b - a) * t;
    const generateId = (prefix) => `${prefix}-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 7)}`;
    const DEG2RAD = Math.PI / 180;

    class MindMap {
        nodes = new Map();
        edges = new Map();
        selectedNode = null;
        selectedEdge = null;
        isLinking = false;
        linkSourceNode = null;
        tempLinkLine = null;
        uiManager = null;
        cameraController = null;
        layoutEngine = null;

        constructor(container) {
            this.container = container;
            this.scene = new THREE.Scene();
            this.cssScene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 20000);
            this.camera.position.z = 700;

            this.webglRenderer = new THREE.WebGLRenderer({canvas: $('#webgl-canvas'), antialias: true, alpha: true});
            this.webglRenderer.setSize(window.innerWidth, window.innerHeight);
            this.webglRenderer.setPixelRatio(window.devicePixelRatio);
            this.webglRenderer.setClearColor(0x000000, 0); // Transparent background

            this.cssRenderer = new CSS3DRenderer();
            this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
            $('#css3d-container').appendChild(this.cssRenderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            this.scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(0.5, 1, 0.75);
            this.scene.add(directionalLight);

            window.addEventListener('resize', this.onWindowResize.bind(this), false);
        }

        addNode(node) {
            if (!node.id) node.id = generateId('node');
            if (this.nodes.has(node.id)) return this.nodes.get(node.id);

            this.nodes.set(node.id, node);
            node.mindMap = this;
            if (node.cssObject) this.cssScene.add(node.cssObject);
            this.layoutEngine?.addNode(node);
            // UIManager setup moved to initialization to ensure all elements exist
            return node;
        }

        removeNode(nodeId) {
            const node = this.nodes.get(nodeId);
            if (!node) return;
            if (this.selectedNode === node) this.setSelectedNode(null);
            if (this.linkSourceNode === node) this.uiManager?.cancelLinking();

            const edgesToRemove = [...this.edges.values()].filter(edge => edge.source === node || edge.target === node);
            edgesToRemove.forEach(edge => this.removeEdge(edge.id));

            node.dispose();
            this.nodes.delete(nodeId);
            this.layoutEngine?.removeNode(node);
        }

        addEdge(sourceNode, targetNode, data = {}) {
            if (!sourceNode || !targetNode || sourceNode === targetNode) return null;
            if ([...this.edges.values()].some(e => (e.source === sourceNode && e.target === targetNode) || (e.source === targetNode && e.target === sourceNode))) return null;

            const edgeId = generateId('edge');
            const edge = new Edge(edgeId, sourceNode, targetNode, data);
            edge.mindMap = this;
            this.edges.set(edgeId, edge);
            if (edge.threeObject) this.scene.add(edge.threeObject);
            this.layoutEngine?.addEdge(edge);
            return edge;
        }

        removeEdge(edgeId) {
            const edge = this.edges.get(edgeId);
            if (!edge) return;
            if (this.selectedEdge === edge) this.setSelectedEdge(null); // Deselect before removing
            edge.dispose();
            this.edges.delete(edgeId);
            this.layoutEngine?.removeEdge(edge);
        }

        getNodeById = (id) => this.nodes.get(id);
        getEdgeById = (id) => this.edges.get(id);

        update() {
            this.nodes.forEach(node => node.update(this));
            this.edges.forEach(edge => edge.update(this));
            this.uiManager?.updateEdgeMenuPosition();
        }

        render() {
            this.webglRenderer.render(this.scene, this.camera);
            this.cssRenderer.render(this.cssScene, this.camera);
        }

        onWindowResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.webglRenderer.setSize(window.innerWidth, window.innerHeight);
            this.cssRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        centerView(targetPosition = null, duration = 0.7) {
            let targetPos;
            if (targetPosition) {
                targetPos = targetPosition.clone();
            } else {
                if (this.nodes.size === 0) targetPos = new THREE.Vector3(0, 0, 0);
                else {
                    targetPos = new THREE.Vector3();
                    this.nodes.forEach(node => targetPos.add(node.position));
                    targetPos.divideScalar(this.nodes.size || 1); // Avoid division by zero
                }
            }
            const distance = this.nodes.size > 1 ? 700 : 400;
            this.cameraController?.moveTo(targetPos.x, targetPos.y, targetPos.z + distance, duration, targetPos);
        }

        focusOnNode(node, duration = 0.6, pushHistory = false) {
            if (!node || !this.cameraController) return;
            const targetPos = node.position.clone();

            const fov = this.camera.fov * DEG2RAD;
            const aspect = this.camera.aspect;
            const nodeSize = Math.max(node.size.width / aspect, node.size.height) * 1.2; // Add 20% padding
            const distance = nodeSize / (2 * Math.tan(fov / 2)) + 50; // Add min distance

            if (pushHistory) this.cameraController.pushState();
            this.cameraController.moveTo(targetPos.x, targetPos.y, targetPos.z + distance, duration, targetPos);
        }

        autoZoom(node) {
            if (!node || !this.cameraController) return;
            const currentTargetNodeId = this.cameraController.getCurrentTargetNodeId();
            if (currentTargetNodeId === node.id) {
                this.cameraController.popState();
            } else {
                this.cameraController.pushState();
                this.cameraController.setCurrentTargetNodeId(node.id);
                this.focusOnNode(node, 0.6, false); // History already pushed
            }
        }

        screen2world(screenX, screenY, targetZ = 0) {
            const vec = new THREE.Vector3((screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1, 0.5);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(vec, this.camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -targetZ);
            const intersectPoint = new THREE.Vector3();
            return raycaster.ray.intersectPlane(plane, intersectPoint) ? intersectPoint : null;
        }

        setSelectedNode(node) {
            if (this.selectedNode === node) return;
            this.selectedNode?.htmlElement?.classList.remove('selected');
            this.selectedNode = node;
            this.selectedNode?.htmlElement?.classList.add('selected');
            if (node) this.setSelectedEdge(null); // Deselect edge when selecting node
        }

        setSelectedEdge(edge) {
            if (this.selectedEdge === edge) return;
            this.selectedEdge?.setHighlight(false);
            this.uiManager?.hideEdgeMenu(); // Hide previous menu
            this.selectedEdge = edge;
            this.selectedEdge?.setHighlight(true);
            if (edge) {
                this.setSelectedNode(null); // Deselect node when selecting edge
                this.uiManager?.showEdgeMenu(edge);
            }
        }

        intersectedObject(screenX, screenY) {
            const vec = new THREE.Vector2((screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(vec, this.camera);
            raycaster.params.Line.threshold = 5; // Increase threshold for line picking

            const edgeObjects = [...this.edges.values()].map(e => e.threeObject).filter(Boolean);
            if (edgeObjects.length === 0) return null;

            const intersects = raycaster.intersectObjects(edgeObjects);

            if (intersects.length > 0) {
                const intersectedLine = intersects[0].object;
                return [...this.edges.values()].find(edge => edge.threeObject === intersectedLine);
            }
            return null; // No edge intersected
        }
    }

    class Node {
        mindMap = null;
        htmlElement = null;
        cssObject = null;
        position = new THREE.Vector3();
        size = {width: 160, height: 70};
        data = {contentScale: 1};
        billboard = true;

        constructor(id, position = {x: 0, y: 0, z: 0}, data = {}) {
            this.id = id ?? generateId('node'); // Ensure ID exists
            this.position.set(position.x, position.y, position.z);
            this.data = {...this.data, ...data};
            this.size.width = data.width ?? this.size.width;
            this.size.height = data.height ?? this.size.height;
            this.htmlElement = this._createHtmlElement();
            this.cssObject = new CSS3DObject(this.htmlElement);
            this.update();
            this.setContentScale(this.data.contentScale); // Apply initial scale
            if (this.data.backgroundColor) {
                this.htmlElement.style.setProperty('--node-bg', this.data.backgroundColor);
            }
        }

        _createHtmlElement() {
            const el = document.createElement('div');
            el.className = 'node-html';
            el.id = `node-html-${this.id}`;
            el.dataset.nodeId = this.id;
            el.style.width = `${this.size.width}px`;
            el.style.height = `${this.size.height}px`;

            el.innerHTML = `
              <div class="node-inner-wrapper">
                  <div class="node-content" spellcheck="false" style="transform: scale(${this.data.contentScale});">${this.data.label || ''}</div>
                  <div class="node-controls">
                      <button class="node-quick-button node-content-zoom-in" title="Zoom In Content (+)">+</button>
                      <button class="node-quick-button node-content-zoom-out" title="Zoom Out Content (-)">-</button>
                      <button class="node-quick-button node-grow" title="Grow Node (Ctrl++)">âžš</button>
                      <button class="node-quick-button node-shrink" title="Shrink Node (Ctrl+-)">âž˜</button>
                      <button class="node-quick-button delete-button node-delete" title="Delete Node (Del)">Ã—</button>
                  </div>
              </div>
              <div class="resize-handle" title="Resize Node"></div>
          `;
            return el;
        }

        setPosition(x, y, z) {
            this.position.set(x, y, z);
        }

        setSize(width, height, scaleContent = false) {
            const oldWidth = this.size.width;
            const oldHeight = this.size.height;
            this.size.width = Math.max(80, width);
            this.size.height = Math.max(40, height);
            if (this.htmlElement) {
                this.htmlElement.style.width = `${this.size.width}px`;
                this.htmlElement.style.height = `${this.size.height}px`;
            }
            if (scaleContent && oldWidth > 0 && oldHeight > 0) {
                const scaleFactor = Math.sqrt((this.size.width * this.size.height) / (oldWidth * oldHeight));
                this.setContentScale(this.data.contentScale * scaleFactor);
            }
            this.mindMap?.layoutEngine?.kick();
        }

        setContentScale(scale) {
            this.data.contentScale = clamp(scale, 0.3, 3.0);
            const contentEl = this.htmlElement?.querySelector('.node-content');
            if (contentEl) {
                contentEl.style.transform = `scale(${this.data.contentScale})`;
            }
        }

        adjustContentScale(delta) {
            this.setContentScale(this.data.contentScale * (1 + delta));
        }

        adjustNodeSize(factor) {
            this.setSize(this.size.width * factor, this.size.height * factor, false); // Don't auto-scale content here
        }

        update(mindMap) {
            if (this.cssObject) {
                this.cssObject.position.copy(this.position);
                if (mindMap && this.billboard) {
                    //TODO 'Billboarding': Face camera slightly (can cause jittering if layout is active)
                    //this.cssObject?.rotation.copy(mindMap.camera.rotation);
                }
            }
        }

        dispose() {
            this.htmlElement?.remove();
            this.cssObject?.parent?.remove(this.cssObject);
        }

        startDrag() {
            this.htmlElement?.classList.add('dragging');
            this.mindMap?.layoutEngine?.fixNode(this);
        }

        drag(newPosition) {
            this.setPosition(newPosition.x, newPosition.y, newPosition.z);
            this.update();
        }

        endDrag() {
            this.htmlElement?.classList.remove('dragging');
            this.mindMap?.layoutEngine?.releaseNode(this);
            this.mindMap?.layoutEngine?.kick();
        }

        startResize() {
            this.htmlElement?.classList.add('resizing');
            this.mindMap?.layoutEngine?.fixNode(this);
        }

        resize(newWidth, newHeight) {
            this.setSize(newWidth, newHeight);
        }

        endResize() {
            this.htmlElement?.classList.remove('resizing');
            this.mindMap?.layoutEngine?.releaseNode(this);
        }
    }

    class NoteNode extends Node {
        constructor(id, pos = {x: 0, y: 0, z: 0}, data = {content: ''}) {
            super(id, pos, {...data, type: 'note', label: data.content}); // Use content as label for HTML
            this._setupRichText();
        }

        _setupRichText() {
            this.htmlElement.classList.add('note-node');
            const contentDiv = this.htmlElement.querySelector('.node-content');
            if (contentDiv) {
                contentDiv.contentEditable = "true";
                contentDiv.innerHTML = this.data.label || ''; // Use label which holds the content
                let debounceTimer;
                contentDiv.addEventListener('input', () => {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        this.data.label = contentDiv.innerHTML;
                    }, 300);
                });
                contentDiv.addEventListener('mousedown', e => e.stopPropagation());
                contentDiv.addEventListener('touchstart', e => e.stopPropagation(), {passive: true});
                contentDiv.addEventListener('wheel', e => { // Allow scrolling inside content
                    if (contentDiv.scrollHeight > contentDiv.clientHeight) {
                        e.stopPropagation();
                    }
                }, {passive: false});
            }
        }
    }

    class Edge {
        mindMap = null;
        threeObject = null;
        data = {color: 0x00d0ff, thickness: 1.5, style: 'solid', constraint: 'normal'}; // Default visual/layout data

        constructor(id, sourceNode, targetNode, data = {}) {
            this.id = id;
            this.source = sourceNode;
            this.target = targetNode;
            this.data = {...this.data, ...data};
            this.threeObject = this._createThreeObject();
            this.update();
        }

        _createThreeObject() {
            const material = new THREE.LineBasicMaterial({
                color: this.data.color,
                linewidth: this.data.thickness, // Note: limited support
                transparent: true,
                opacity: 0.6,
                depthTest: false, // Render edges slightly on top
            });
            const points = [this.source.position.clone(), this.target.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            line.renderOrder = -1; // Render before nodes if depthTest is true
            line.userData.edgeId = this.id; // Link back to edge object
            return line;
        }

        update(mindMap) {
            if (!this.threeObject || !this.source || !this.target) return;
            const positions = this.threeObject.geometry.attributes.position;
            positions.setXYZ(0, this.source.position.x, this.source.position.y, this.source.position.z);
            positions.setXYZ(1, this.target.position.x, this.target.position.y, this.target.position.z);
            positions.needsUpdate = true;
            this.threeObject.geometry.computeBoundingSphere();
        }

        setHighlight(highlight) {
            if (!this.threeObject) return;
            this.threeObject.material.opacity = highlight ? 1.0 : 0.6;
            this.threeObject.material.color.set(highlight ? 0x00ffff : this.data.color);
            // Consider Line2 for thickness change on highlight if needed
            // this.threeObject.material.linewidth = highlight ? this.data.thickness * 1.5 : this.data.thickness;
            this.threeObject.material.needsUpdate = true;
        }

        dispose() {
            if (this.threeObject) {
                this.threeObject.geometry?.dispose();
                this.threeObject.material?.dispose();
                this.threeObject.parent?.remove(this.threeObject);
                this.threeObject = null; // Clear reference
            }
        }
    }

    class UIManager {
        draggedNode = null;
        resizedNode = null;
        resizeStartPos = {x: 0, y: 0};
        resizeStartSize = {width: 0, height: 0};
        dragOffset = new THREE.Vector3();
        isMouseDown = false;
        isRightMouseDown = false; // Track right mouse specifically for autozoom cancel
        potentialClick = true;
        lastPointerPos = {x: 0, y: 0};
        confirmCallback = null;
        hoveredEdge = null;
        edgeMenu = null; // Will hold the CSS3DObject wrapper

        constructor(mindMap) {
            this.mindMap = mindMap;
            this.container = mindMap.container;
            this.contextMenu = $('#context-menu');
            this.confirmDialog = $('#confirm-dialog');
            this._bindEvents();
        }

        _bindEvents() {
            this.container.addEventListener('pointerdown', this.onPointerDown.bind(this));
            window.addEventListener('pointermove', this.onPointerMove.bind(this));
            window.addEventListener('pointerup', this.onPointerUp.bind(this));
            this.container.addEventListener('contextmenu', this.onContextMenu.bind(this));
            document.addEventListener('click', (e) => {
                if (!this.contextMenu.contains(e.target)) this.hideContextMenu();
                // Hide edge menu on outside click
                // FIX: Check edgeMenu.element.contains
                if (this.edgeMenu && this.edgeMenu.element && !this.edgeMenu.element.contains(e.target)) {
                    // Also ensure the click wasn't on the edge itself which might re-trigger the menu
                    const edgeObj = this.mindMap.intersectedObject(e.clientX, e.clientY);
                    if (this.mindMap.selectedEdge !== edgeObj) {
                        this.mindMap.setSelectedEdge(null); // This implicitly hides the menu via the setter
                    }
                }
            }, true); // Use capture phase
            this.contextMenu.addEventListener('click', this.onMenuClick.bind(this));
            $('#confirm-yes').addEventListener('click', this.onConfirmYes.bind(this));
            $('#confirm-no').addEventListener('click', this.onConfirmNo.bind(this));
            window.addEventListener('keydown', this.onKeyDown.bind(this));
            //this.container.addEventListener('wheel', this.onNodeWheel.bind(this), { passive: false });
        }

        targetInfo(event) {
            const e = document.elementFromPoint(event.clientX, event.clientY);
            const nodeElement = e?.closest('.node-html');
            const resizeHandle = e?.closest('.resize-handle');
            const nodeControls = e?.closest('.node-controls button'); // Any button in controls
            const contentEditable = e?.closest('.node-content[contenteditable="true"]');
            const interactiveElement = e?.closest('.node-content button, .node-content input, .node-content a');

            const node = nodeElement ? this.mindMap.getNodeById(nodeElement.dataset.nodeId) : null;
            // Check edge intersection only if not clicking on a node element or its controls
            const intersectedEdge = (!nodeElement) ? this.mindMap.intersectedObject(event.clientX, event.clientY) : null;

            return {
                element: e,
                nodeElement,
                resizeHandle,
                nodeControls,
                contentEditable,
                interactiveElement,
                node,
                intersectedEdge
            };
        }

        onPointerDown(e) {
            const {
                nodeElement,
                resizeHandle,
                nodeControls,
                contentEditable,
                interactiveElement,
                node,
                intersectedEdge
            } = this.targetInfo(e);
            const eb = e.button;
            this.isMouseDown = eb === 0; // Primary button
            this.isRightMouseDown = eb === 2;
            this.potentialClick = true;
            this.lastPointerPos = {x: e.clientX, y: e.clientY};

            if (eb === 2) { // Right click
                e.preventDefault();
                // Autozoom handled on pointerup/contextmenu
                return;
            }

            // --- Handle Node Quick Buttons / Resize First ---
            if (this.isMouseDown) {
              if (nodeControls && node) { // Clicked a button within node controls
                e.preventDefault();
                e.stopPropagation();
                const b = e.target.closest('button');
                let bClasses = b?.classList;
                if (bClasses?.contains('node-delete')) this.showConfirm(`Delete node "${node.id.substring(0, 10)}..."?`, () => this.mindMap.removeNode(node.id));
                else if (bClasses?.contains('node-content-zoom-in')) node.adjustContentScale(0.15);
                else if (bClasses?.contains('node-content-zoom-out')) node.adjustContentScale(-0.15);
                else if (bClasses?.contains('node-grow')) node.adjustNodeSize(1.25);
                else if (bClasses?.contains('node-shrink')) node.adjustNodeSize(0.8);
                this.hideContextMenu();
                return;
              }
              if (resizeHandle && node) {
                e.preventDefault();
                e.stopPropagation();
                this.resizedNode = node;
                this.resizedNode.startResize();
                this.resizeStartPos = {x: e.clientX, y: e.clientY};
                this.resizeStartSize = {...this.resizedNode.size};
                this.container.style.cursor = 'nwse-resize';
                this.hideContextMenu();
                return;
              }

              // --- Handle Node Drag / Selection ---
              // Allow drag only if clicking directly on node bg, not controls/content/interactive
              if (nodeElement && !nodeControls && !resizeHandle && !interactiveElement && !contentEditable) {
                e.preventDefault(); // Prevent text selection/browser drag
                this.draggedNode = node; // 'node' comes from _getTargetInfo
                // FIX: Check if node exists before calling startDrag
                if (this.draggedNode) {
                  this.draggedNode.startDrag();
                  const worldPos = this.mindMap.screen2world(e.clientX, e.clientY, this.draggedNode.position.z);
                  this.dragOffset = worldPos ? worldPos.sub(this.draggedNode.position) : new THREE.Vector3();
                  this.container.style.cursor = 'grabbing';
                  this.mindMap.setSelectedNode(node); // Select node on drag start
                } else {
                  console.warn("Attempted to drag non-existent node for element:", nodeElement);
                  this.draggedNode = null; // Ensure it's null if node lookup failed
                }
                this.hideContextMenu();
                return;
              }
            }
            // If clicking interactive or editable, stop propagation so background doesn't pan
            if (nodeElement && (interactiveElement || contentEditable)) {
                e.stopPropagation(); // Prevent pan
                this.mindMap.setSelectedNode(node); // Select node even when clicking inside
                this.hideContextMenu();
                return;
            }

            // --- Handle Edge Selection ---
            if (intersectedEdge && !node) { // Prioritize nodes over edges if overlapping
                e.preventDefault();
                this.mindMap.setSelectedEdge(intersectedEdge);
                this.hideContextMenu();
                return; // Don't pan if edge selected
            }

            // --- Handle Background Interaction (Panning or Deselection) ---
            if (!nodeElement && !intersectedEdge) { // Clicked on background
                this.hideContextMenu();
                if (this.mindMap.selectedNode || this.mindMap.selectedEdge) {
                    // Deselect on background click
                    this.mindMap.setSelectedNode(null);
                    this.mindMap.setSelectedEdge(null);
                } else {
                    // Allow CameraController to handle panning (it checks isMouseDown)
                    this.mindMap.cameraController?.startPan(e);
                }
            }
        }

        onPointerMove(e) {
            const dx = e.clientX - this.lastPointerPos.x;
            const dy = e.clientY - this.lastPointerPos.y;
            if (dx !== 0 || dy !== 0) this.potentialClick = false;
            this.lastPointerPos = {x: e.clientX, y: e.clientY};

            // --- Handle Resizing ---
            if (this.resizedNode) {
                e.preventDefault();
                const newWidth = this.resizeStartSize.width + (e.clientX - this.resizeStartPos.x);
                const newHeight = this.resizeStartSize.height + (e.clientY - this.resizeStartPos.y);
                this.resizedNode.resize(newWidth, newHeight);
                return; // Prevent other move actions
            }

            // --- Handle Dragging ---
            if (this.draggedNode) {
                e.preventDefault();
                const worldPos = this.mindMap.screen2world(e.clientX, e.clientY, this.draggedNode.position.z);
                if (worldPos) this.draggedNode.drag(worldPos.sub(this.dragOffset));
                return; // Prevent other move actions
            }

            // --- Handle Linking Line ---
            if (this.mindMap.isLinking) {
                e.preventDefault(); // Prevent panning while linking
                this._updateTempLinkLine(e.clientX, e.clientY);
                const {node} = this.targetInfo(e);
                $$('.node-html.linking-target').forEach(el => el.classList.remove('linking-target'));
                if (node && node !== this.mindMap.linkSourceNode) {
                    node.htmlElement?.classList.add('linking-target');
                }
                return;
            }

            // --- Handle Panning (delegated to CameraController) ---
            this.mindMap.cameraController?.pan(e);

            // --- Handle Edge Highlighting on Hover (if nothing else is active) ---
            if (!this.isMouseDown && !this.resizedNode && !this.draggedNode && !this.mindMap.isLinking) {
                const {intersectedEdge} = this.targetInfo(e);
                if (this.hoveredEdge !== intersectedEdge) {
                    if (this.hoveredEdge && this.hoveredEdge !== this.mindMap.selectedEdge) {
                        this.hoveredEdge.setHighlight(false);
                    }
                    this.hoveredEdge = intersectedEdge;
                    if (this.hoveredEdge && this.hoveredEdge !== this.mindMap.selectedEdge) {
                        this.hoveredEdge.setHighlight(true);
                    }
                }
            }
        }

        onPointerUp(e) {
            this.container.style.cursor = this.mindMap.isLinking ? 'crosshair' : 'grab';

            if (this.resizedNode) {
                this.resizedNode.endResize();
                this.resizedNode = null;
            } else if (this.draggedNode) {
                this.draggedNode.endDrag();
                this.draggedNode = null;
            } else if (this.mindMap.isLinking) {
                this._endLinking(e);
            } else if (e.button === 1) { // Middle button
                const {node} = this.targetInfo(e);
                if (node) {
                    this.mindMap.autoZoom(node);
                    e.preventDefault();
                }
            } else if (e.button === 2 && this.isRightMouseDown && this.potentialClick) { // Right-click finish
                // Context menu should appear via 'contextmenu' event
            } else if (e.button === 0 && this.potentialClick) { // Primary click finish
                const {
                    node,
                    intersectedEdge,
                    contentEditable,
                    interactiveElement,
                    nodeControls,
                    resizeHandle
                } = this.targetInfo(e);
                // If click was on a control, it was handled in pointerdown, do nothing here
                if (!nodeControls && !resizeHandle) {
                    if (node && !contentEditable && !interactiveElement) {
                        // Simple click on node (already selected in pointerdown)
                    } else if (intersectedEdge && !node) {
                        // Simple click on edge (already selected in pointerdown)
                    } else if (!node && !intersectedEdge && !this.mindMap.cameraController?.isPanning) {
                        // Background click - deselect handled by document click listener
                    }
                }
            }

            // End panning
            this.mindMap.cameraController?.endPan();

            this.isMouseDown = false;
            this.isRightMouseDown = false;
            this.potentialClick = false; // Reset potential click flag
            $$('.node-html.linking-target').forEach(el => el.classList.remove('linking-target'));
        }

        onContextMenu(e) {
            e.preventDefault();
            this.hideContextMenu(); // Hide previous first
            const {node, intersectedEdge} = this.targetInfo(e);

            let items = [];
            if (node) {
                if (this.mindMap.selectedNode !== node) this.mindMap.setSelectedNode(node); // Select node on right click if not already selected
                items = [
                    {
                        label: "Edit Content ðŸ“",
                        action: "edit-node",
                        nodeId: node.id,
                        disabled: !(node instanceof NoteNode)
                    },
                    {label: "Start Link âœ¨", action: "start-link", nodeId: node.id},
                    {label: "Auto Zoom / Back ðŸ–±ï¸", action: "autozoom-node", nodeId: node.id},
                    {type: 'separator'},
                    {label: "Delete Node ðŸ—‘ï¸", action: "delete-node", nodeId: node.id},
                ];
            } else if (intersectedEdge) {
                if (this.mindMap.selectedEdge !== intersectedEdge) this.mindMap.setSelectedEdge(intersectedEdge); // Select edge on right click
                items = [
                    {label: "Edit Edge Style...", action: "edit-edge", edgeId: intersectedEdge.id}, // Placeholder
                    {label: "Reverse Edge Direction", action: "reverse-edge", edgeId: intersectedEdge.id},
                    {type: 'separator'},
                    {label: "Delete Edge ðŸ—‘ï¸", action: "delete-edge", edgeId: intersectedEdge.id},
                ];
            } else {
                // Deselect if right-clicking background
                this.mindMap.setSelectedNode(null);
                this.mindMap.setSelectedEdge(null);
                const worldPos = this.mindMap.screen2world(e.clientX, e.clientY, 0);
                items = [
                    {
                        label: "Create Note Here âž•",
                        action: "create-note",
                        position: worldPos ? JSON.stringify(worldPos) : null
                    },
                    {label: "Center View ðŸ§­", action: "center-view"},
                    {label: "Reset Zoom & Pan", action: "reset-view"},
                ];
            }

            if (items.length > 0) this.showContextMenu(e.clientX, e.clientY, items);
        }

        showContextMenu(x, y, items) {
            this.contextMenu.innerHTML = '';
            const ul = document.createElement('ul');
            items.forEach(item => {
                if (item.type === 'separator') {
                    const li = document.createElement('li');
                    li.className = 'separator';
                    ul.appendChild(li);
                    return;
                }
                if (item.disabled) return;
                const li = document.createElement('li');
                li.textContent = item.label;
                Object.entries(item).forEach(([key, value]) => {
                    if (value !== undefined && value !== null && key !== 'type' && key !== 'label') li.dataset[key] = value;
                });
                ul.appendChild(li);
            });
            this.contextMenu.appendChild(ul);

            const menuWidth = this.contextMenu.offsetWidth;
            const menuHeight = this.contextMenu.offsetHeight;
            let finalX = x + 5;
            let finalY = y + 5;
            if (finalX + menuWidth > window.innerWidth) finalX = x - menuWidth - 5;
            if (finalY + menuHeight > window.innerHeight) finalY = y - menuHeight - 5;
            finalX = Math.max(5, finalX);
            finalY = Math.max(5, finalY);

            this.contextMenu.style.left = `${finalX}px`;
            this.contextMenu.style.top = `${finalY}px`;
            this.contextMenu.style.display = 'block';
        }

        hideContextMenu = () => {
            if (this.contextMenu) this.contextMenu.style.display = 'none';
        }

        onMenuClick(event) {
            const li = event.target.closest('li');
            if (!li || !li.dataset.action) return;
            const data = li.dataset;
            const action = data.action;
            this.hideContextMenu();

            switch (action) {
                case 'edit-node': {
                    const node = this.mindMap.getNodeById(data.nodeId);
                    const contentDiv = node?.htmlElement?.querySelector('.node-content');
                    if (contentDiv?.contentEditable === "true") contentDiv.focus();
                    break;
                }
                case 'delete-node':
                    this.showConfirm(`Delete node "${data.nodeId.substring(0, 10)}..."?`, () => this.mindMap.removeNode(data.nodeId));
                    break;
                case 'delete-edge':
                    this.showConfirm(`Delete edge "${data.edgeId.substring(0, 10)}..."?`, () => this.mindMap.removeEdge(data.edgeId));
                    break;
                case 'autozoom-node': {
                    const node = this.mindMap.getNodeById(data.nodeId);
                    if (node) this.mindMap.autoZoom(node);
                    break;
                }
                case 'create-note': {
                    if (!data.position) break;
                    const pos = JSON.parse(data.position);
                    const newNode = this.mindMap.addNode(new NoteNode(null, pos, {content: 'New Note âœ¨'}));
                    this.mindMap.layoutEngine?.kick();
                    setTimeout(() => {
                        this.mindMap.focusOnNode(newNode, 0.6, true); // Push history for new node focus
                        newNode.htmlElement?.querySelector('.node-content')?.focus();
                        this.mindMap.setSelectedNode(newNode); // Select the new node
                    }, 100);
                    break;
                }
                case 'center-view':
                    this.mindMap.centerView();
                    break;
                case 'reset-view':
                    this.mindMap.cameraController?.resetView();
                    break;
                case 'start-link': {
                    const sourceNode = this.mindMap.getNodeById(data.nodeId);
                    if (sourceNode) {
                        this.mindMap.isLinking = true;
                        this.mindMap.linkSourceNode = sourceNode;
                        this.container.style.cursor = 'crosshair';
                        this._startTempLinkLine(sourceNode);
                    }
                    break;
                }
                case 'reverse-edge': {
                    const edge = this.mindMap.getEdgeById(data.edgeId);
                    if (edge) {
                        const oldSource = edge.source;
                        edge.source = edge.target;
                        edge.target = oldSource;
                        edge.update(); // Update visual immediately
                        this.mindMap.layoutEngine?.kick(); // Nudge layout
                    }
                    break;
                }
                case 'edit-edge':
                    console.warn("Edit Edge Style action not fully implemented.");
                    // Ensure menu is shown if not already (might be hidden by context menu closing)
                    this.showEdgeMenu(this.mindMap.getEdgeById(data.edgeId));
                    break;
            }
        }

        showConfirm(message, onConfirm) {
            $('#confirm-message').textContent = message;
            this.confirmCallback = onConfirm;
            this.confirmDialog.style.display = 'block';
        }

        hideConfirm = () => {
            this.confirmDialog.style.display = 'none';
            this.confirmCallback = null;
        }
        onConfirmYes = () => {
            this.confirmCallback?.();
            this.hideConfirm();
        }
        onConfirmNo = () => {
            this.hideConfirm();
        }

        _startTempLinkLine(sourceNode) {
            this._removeTempLinkLine();
            const material = new THREE.LineDashedMaterial({
                color: 0xffaa00,
                linewidth: 2,
                dashSize: 8,
                gapSize: 4,
                transparent: true,
                opacity: 0.9,
                depthTest: false
            });
            const points = [sourceNode.position.clone(), sourceNode.position.clone()];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            this.mindMap.tempLinkLine = new THREE.Line(geometry, material);
            this.mindMap.tempLinkLine.computeLineDistances();
            this.mindMap.tempLinkLine.renderOrder = 1;
            this.mindMap.scene.add(this.mindMap.tempLinkLine);
        }

        _updateTempLinkLine(screenX, screenY) {
            if (!this.mindMap.tempLinkLine || !this.mindMap.linkSourceNode) return;
            const targetPos = this.mindMap.screen2world(screenX, screenY, this.mindMap.linkSourceNode.position.z);
            if (targetPos) {
                const positions = this.mindMap.tempLinkLine.geometry.attributes.position;
                positions.setXYZ(1, targetPos.x, targetPos.y, targetPos.z);
                positions.needsUpdate = true;
                this.mindMap.tempLinkLine.geometry.computeBoundingSphere();
                this.mindMap.tempLinkLine.computeLineDistances();
            }
        }

        _removeTempLinkLine() {
            if (this.mindMap.tempLinkLine) {
                this.mindMap.tempLinkLine.geometry?.dispose();
                this.mindMap.tempLinkLine.material?.dispose();
                this.mindMap.scene.remove(this.mindMap.tempLinkLine);
                this.mindMap.tempLinkLine = null;
            }
        }

        _endLinking(event) {
            this._removeTempLinkLine();
            const {node: targetNode} = this.targetInfo(event);
            if (targetNode && targetNode !== this.mindMap.linkSourceNode) {
                this.mindMap.addEdge(this.mindMap.linkSourceNode, targetNode);
            }
            this.cancelLinking();
        }

        cancelLinking() {
            this._removeTempLinkLine();
            this.mindMap.isLinking = false;
            this.mindMap.linkSourceNode = null;
            this.container.style.cursor = 'grab';
            $$('.node-html.linking-target').forEach(el => el.classList.remove('linking-target'));
        }

        onKeyDown(event) {
            if (document.activeElement && ['INPUT', 'TEXTAREA', 'DIV'].includes(document.activeElement.tagName) && document.activeElement.isContentEditable) {
                if (event.key === 'Escape' && this.mindMap.isLinking) {
                    event.preventDefault();
                    this.cancelLinking();
                }
                return; // Don't process shortcuts if editing text
            }

            const selectedNode = this.mindMap.selectedNode;
            const selectedEdge = this.mindMap.selectedEdge;

            switch (event.key) {
                case 'Delete':
                case 'Backspace':
                    if (selectedNode) {
                        this.removeTry(selectedNode, event);
                    } else if (selectedEdge) {
                        this.removeTry(selectedEdge, event);
                    }
                    break;
                case 'Escape':
                    event.preventDefault();
                    if (this.mindMap.isLinking) {
                        this.cancelLinking();
                    } else if (this.contextMenu.style.display === 'block') {
                        this.hideContextMenu();
                    } else if (this.confirmDialog.style.display === 'block') {
                        this.hideConfirm();
                    } else if (this.edgeMenu) {
                        this.mindMap.setSelectedEdge(null); // Deselect edge (hides menu)
                    } else if (selectedNode || selectedEdge) {
                        this.mindMap.setSelectedNode(null);
                        this.mindMap.setSelectedEdge(null);
                    }
                    break;
                case 'Enter':
                    if (selectedNode && selectedNode instanceof NoteNode) {
                        event.preventDefault();
                        selectedNode.htmlElement?.querySelector('.node-content')?.focus();
                    }
                    break;
                case '+':
                case '=': // Often shares key with +
                    if (selectedNode && event.ctrlKey) { // Ctrl + + : Grow Node
                        event.preventDefault();
                        selectedNode.adjustNodeSize(1.25);
                    } else if (selectedNode) { // Just + : Zoom Content
                        event.preventDefault();
                        selectedNode.adjustContentScale(0.15);
                    }
                    break;
                case '-':
                case '_': // Often shares key with -
                    if (selectedNode && event.ctrlKey) { // Ctrl + - : Shrink Node
                        event.preventDefault();
                        selectedNode.adjustNodeSize(0.8);
                    } else if (selectedNode) { // Just - : Zoom Content
                        event.preventDefault();
                        selectedNode.adjustContentScale(-0.15);
                    }
                    break;
                case ' ': // Spacebar - Recenter on selection or overall view
                    if (selectedNode) {
                        event.preventDefault();
                        this.mindMap.focusOnNode(selectedNode, 0.5, true);
                    } else if (selectedEdge) {
                        event.preventDefault();
                        // Focus on midpoint of edge?
                        const midPoint = new THREE.Vector3().lerpVectors(selectedEdge.source.position, selectedEdge.target.position, 0.5);
                        const dist = selectedEdge.source.position.distanceTo(selectedEdge.target.position);
                        this.mindMap.cameraController?.pushState();
                        this.mindMap.cameraController?.moveTo(midPoint.x, midPoint.y, midPoint.z + dist * 0.6 + 100, 0.5, midPoint);
                    } else {
                        event.preventDefault();
                        this.mindMap.centerView();
                    }
                    break;
            }
        }

        removeTry(selected, event) {
            event.preventDefault();
            this.showConfirm(`Delete node "${selected.id.substring(0, 10)}..."?`, () => this.mindMap.removeNode(selected.id));
        }

        onNodeWheel(event) {
            const {node, contentEditable} = this.targetInfo(event);
            // Allow wheel scroll inside contentEditable OR if node controls are hovered
            const controlsHovered = event.target.closest('.node-controls');
            if (node && !contentEditable && !controlsHovered) {
                event.preventDefault();
                event.stopPropagation();
                const delta = -event.deltaY * 0.001; // Adjust sensitivity
                node.adjustContentScale(delta);
            }
            // Allow default wheel behavior (zoom/pan) if not over a node's main area
        }

        showEdgeMenu(edge) {
            if (!edge || this.edgeMenu) return; // Don't show if already visible or no edge

            const menu = document.createElement('div');
            menu.className = 'edge-menu-frame';
            menu.dataset.edgeId = edge.id;
            menu.innerHTML = `
              <button title="Color (NYI)" data-action="color">ðŸŽ¨</button>
              <button title="Thickness (NYI)" data-action="thickness">âž–</button>
              <button title="Style (NYI)" data-action="style">ã€°ï¸</button>
              <button title="Constraint (NYI)" data-action="constraint">ðŸ”—</button>
              <button title="Delete Edge" class="delete" data-action="delete">Ã—</button>
          `;

            menu.addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if (!button) return;
                const action = button.dataset.action;
                e.stopPropagation(); // Prevent click from bubbling to document/deselecting

                switch (action) {
                    case 'delete':
                        this.showConfirm(`Delete edge "${edge.id.substring(0, 10)}..."?`, () => this.mindMap.removeEdge(edge.id));
                        // No need to hide menu here, removeEdge->setSelectedEdge(null) handles it
                        break;
                    default:
                        console.warn(`Edge menu action '${action}' not implemented.`);
                }
            });

            this.edgeMenu = new CSS3DObject(menu);
            this.mindMap.cssScene.add(this.edgeMenu);
            this.updateEdgeMenuPosition(); // Initial position
        }

        hideEdgeMenu() {
            if (this.edgeMenu) {
                this.edgeMenu.element?.remove(); // Clean up HTML element
                this.edgeMenu.parent?.remove(this.edgeMenu);
                this.edgeMenu = null;
            }
        }

        updateEdgeMenuPosition() {
            if (!this.edgeMenu || !this.mindMap.selectedEdge) return;
            const edge = this.mindMap.selectedEdge;
            const midPoint = new THREE.Vector3().lerpVectors(edge.source.position, edge.target.position, 0.5);
            this.edgeMenu.position.copy(midPoint);
            // Optional: Make menu face camera
            // this.edgeMenu.rotation.copy(this.mindMap.camera.rotation);
        }
    }

    class Camera {
        isPanning = false;
        panStart = new THREE.Vector2();
        targetPosition = new THREE.Vector3();
        targetLookAt = new THREE.Vector3();
        currentLookAt = new THREE.Vector3();
        zoomSpeed = 0.0015;
        panSpeed = 0.8;
        minZoom = 20;
        maxZoom = 15000;
        dampingFactor = 0.12;
        animationFrameId = null;
        viewHistory = []; // Stack for autozoom back/forward
        maxHistory = 20;
        currentTargetNodeId = null; // Track which node is targeted by autozoom
        initialState = null; // Store initial state after first positioning

        constructor(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            // Initial state set after first centerView/focus
            this.targetPosition.copy(camera.position);
            this.targetLookAt.copy(new THREE.Vector3(0, 0, 0)); // Assume looking at origin initially
            this.currentLookAt.copy(this.targetLookAt);

            this._bindEvents();
            this.update();
        }

        _bindEvents() {
            // Wheel and pointer events handled by UIManager, which calls camera methods
        }

        setInitialState() {
            if (!this.initialState) {
                this.initialState = {
                    position: this.camera.position.clone(),
                    lookAt: this.currentLookAt.clone() // Use current smoothed lookAt
                };
            }
        }

        // Called by UIManager on background pointer down
        startPan(event) {
            if (event.button !== 0 || this.isPanning) return; // Only primary button pan, prevent re-entry
            this.isPanning = true;
            this.panStart.set(event.clientX, event.clientY);
            this.domElement.classList.add('panning');
            gsap.killTweensOf(this.targetPosition);
            gsap.killTweensOf(this.targetLookAt);
            this.currentTargetNodeId = null; // User interaction cancels autozoom target
        }

        // Called by UIManager on pointer move if panning
        pan(event) {
            if (!this.isPanning) return;
            const deltaX = event.clientX - this.panStart.x;
            const deltaY = event.clientY - this.panStart.y;

            const cameraDist = this.camera.position.distanceTo(this.currentLookAt);
            const vFOV = this.camera.fov * DEG2RAD;
            // Use clientHeight which is more reliable than domElement.clientHeight if domElement is canvas
            const viewHeight = this.domElement.clientHeight || window.innerHeight;
            const height = 2 * Math.tan(vFOV / 2) * Math.max(1, cameraDist);

            const panX = -(deltaX / viewHeight) * height * this.panSpeed;
            const panY = (deltaY / viewHeight) * height * this.panSpeed;

            const right = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 0);
            const up = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 1);
            const panOffset = right.multiplyScalar(panX).add(up.multiplyScalar(panY));

            this.targetPosition.add(panOffset);
            this.targetLookAt.add(panOffset);
            this.panStart.set(event.clientX, event.clientY);
        }

        // Called by UIManager on pointer up if panning
        endPan() {
            if (this.isPanning) {
                this.isPanning = false;
                this.domElement.classList.remove('panning');
            }
        }

        // Called by UIManager on wheel event if not handled by node
        zoom(event) {
            event.preventDefault();
            gsap.killTweensOf(this.targetPosition);
            gsap.killTweensOf(this.targetLookAt);
            this.currentTargetNodeId = null; // User interaction cancels autozoom target

            const delta = -event.deltaY * this.zoomSpeed;
            const currentDist = this.targetPosition.distanceTo(this.targetLookAt);
            let newDist = currentDist * Math.pow(0.95, delta * 12); // Adjusted multiplier
            newDist = clamp(newDist, this.minZoom, this.maxZoom);

            const zoomFactor = (newDist - currentDist); // Amount to move along direction

            // Zoom towards mouse pointer projected onto the lookAt plane
            const mouseWorldPos = this._getLookAtPlaneIntersection(event.clientX, event.clientY);
            const direction = new THREE.Vector3();

            if (mouseWorldPos) {
                direction.copy(mouseWorldPos).sub(this.targetPosition).normalize();
            } else {
                // Fallback: Zoom along camera view direction
                this.camera.getWorldDirection(direction);
            }
            this.targetPosition.addScaledVector(direction, zoomFactor);
        }

        moveTo(x, y, z, duration = 0.7, lookAtTarget = null) {
            this.setInitialState(); // Ensure initial state is set before first move
            const targetPos = new THREE.Vector3(x, y, z);
            const targetLook = lookAtTarget ? lookAtTarget.clone() : new THREE.Vector3(x, y, 0); // Default lookAt XY plane

            gsap.killTweensOf(this.targetPosition); // Ensure smooth transition
            gsap.killTweensOf(this.targetLookAt);

            gsap.to(this.targetPosition, {
                x: targetPos.x,
                y: targetPos.y,
                z: targetPos.z,
                duration: duration,
                ease: "power3.out",
                overwrite: true
            });
            gsap.to(this.targetLookAt, {
                x: targetLook.x,
                y: targetLook.y,
                z: targetLook.z,
                duration: duration,
                ease: "power3.out",
                overwrite: true
            });
        }

        resetView(duration = 0.7) {
            if (this.initialState) {
                this.moveTo(this.initialState.position.x, this.initialState.position.y, this.initialState.position.z, duration, this.initialState.lookAt);
            } else {
                // Fallback if initial state wasn't set (shouldn't happen ideally)
                this.moveTo(0, 0, 700, duration, new THREE.Vector3(0, 0, 0));
            }
            this.viewHistory = []; // Clear history on reset
            this.currentTargetNodeId = null;
        }

        pushState() {
            if (this.viewHistory.length >= this.maxHistory) {
                this.viewHistory.shift(); // Remove oldest state
            }
            // Push the *current* target state, not the camera's potentially lagging position
            this.viewHistory.push({
                position: this.targetPosition.clone(),
                lookAt: this.targetLookAt.clone(),
                targetNodeId: this.currentTargetNodeId
            });
        }

        popState(duration = 0.6) {
            if (this.viewHistory.length > 0) {
                const prevState = this.viewHistory.pop();
                this.moveTo(prevState.position.x, prevState.position.y, prevState.position.z, duration, prevState.lookAt);
                this.currentTargetNodeId = prevState.targetNodeId; // Restore previous target
            } else {
                this.resetView(duration); // Go to initial state if history is empty
            }
        }

        getCurrentTargetNodeId = () => this.currentTargetNodeId;
        setCurrentTargetNodeId = (nodeId) => {
            this.currentTargetNodeId = nodeId;
        };

        update = () => {
            const deltaPos = this.targetPosition.distanceTo(this.camera.position);
            const deltaLookAt = this.targetLookAt.distanceTo(this.currentLookAt);

            // Only lerp if moving significantly or panning
            if (deltaPos > 0.01 || deltaLookAt > 0.01 || this.isPanning) {
                this.camera.position.lerp(this.targetPosition, this.dampingFactor);
                this.currentLookAt.lerp(this.targetLookAt, this.dampingFactor);
                this.camera.lookAt(this.currentLookAt);
            } else if (!gsap.isTweening(this.targetPosition) && !gsap.isTweening(this.targetLookAt)) {
                // Snap to final position only if close enough AND no animation is running
                if (deltaPos > 0 || deltaLookAt > 0) { // Avoid unnecessary updates if already there
                    this.camera.position.copy(this.targetPosition);
                    this.currentLookAt.copy(this.targetLookAt);
                    this.camera.lookAt(this.currentLookAt);
                }
            }
            this.animationFrameId = requestAnimationFrame(this.update);
        }

        dispose() {
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            gsap.killTweensOf(this.targetPosition);
            gsap.killTweensOf(this.targetLookAt);
            // Remove event listeners if they were added directly here
        }

        _getLookAtPlaneIntersection(screenX, screenY) {
            const vec = new THREE.Vector3((screenX / window.innerWidth) * 2 - 1, -(screenY / window.innerHeight) * 2 + 1, 0.5);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(vec, this.camera);
            const camDir = new THREE.Vector3();
            this.camera.getWorldDirection(camDir);
            // Use targetLookAt for the plane's reference point
            const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(camDir.negate(), this.targetLookAt);
            const intersectPoint = new THREE.Vector3();
            return raycaster.ray.intersectPlane(plane, intersectPoint) ? intersectPoint : null;
        }
    }

    class ForceLayout {
        nodes = [];
        edges = [];
        velocities = new Map();
        fixedNodes = new Set();
        isRunning = false;
        animationFrameId = null;
        energy = Infinity;
        lastKickTime = 0;
        autoStopTimeout = null;

        settings = {
            repulsion: 3000,
            attraction: 0.001,
            idealEdgeLength: 200,
            centerStrength: 0.0005,
            damping: 0.92, // Slightly less damping for more subtle movement
            minEnergyThreshold: 0.1, // Stop when energy is low
            gravityCenter: new THREE.Vector3(0, 0, 0),
            zSpreadFactor: 0.15, // Slightly more Z influence
            autoStopDelay: 4000 // Stop simulation after 4s of inactivity
        };

        constructor(mindMap) {
            this.mindMap = mindMap;
        }

        addNode(node) {
            if (!this.velocities.has(node.id)) {
                this.nodes.push(node);
                this.velocities.set(node.id, new THREE.Vector3());
                this.kick();
            }
        }

        removeNode(node) {
            this.nodes = this.nodes.filter(n => n !== node);
            this.velocities.delete(node.id);
            this.fixedNodes.delete(node);
            this.kick();
        }

        addEdge(edge) {
            if (!this.edges.includes(edge)) {
                this.edges.push(edge);
                this.kick();
            }
        }

        removeEdge(edge) {
            this.edges = this.edges.filter(e => e !== edge);
            this.kick();
        }

        fixNode(node) {
            this.fixedNodes.add(node);
            this.velocities.get(node.id)?.set(0, 0, 0);
        }

        releaseNode(node) {
            this.fixedNodes.delete(node);
        }

        runOnce(steps = 100) {
            for (let i = 0; i < steps; i++) {
                if (this._calculateStep() < this.settings.minEnergyThreshold) break;
            }
        }

        start() {
            if (this.isRunning) return;
            this.isRunning = true;
            const loop = () => {
                if (!this.isRunning) return;
                this.energy = this._calculateStep();
                // Check energy and time since last kick for auto-stop
                if (this.energy < this.settings.minEnergyThreshold && Date.now() - this.lastKickTime > this.settings.autoStopDelay) {
                    this.stop();
                } else {
                    this.animationFrameId = requestAnimationFrame(loop);
                }
            };
            this.animationFrameId = requestAnimationFrame(loop);
        }

        stop() {
            this.isRunning = false;
            if (this.animationFrameId) cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
            clearTimeout(this.autoStopTimeout);
            this.autoStopTimeout = null;
            // console.log("Layout simulation stopped.");
        }

        kick(intensity = 1) {
            this.lastKickTime = Date.now();
            this.nodes.forEach(node => {
                if (!this.fixedNodes.has(node)) {
                    this.velocities.get(node.id)?.add(
                        new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, (Math.random() - 0.5) * this.settings.zSpreadFactor)
                            .normalize().multiplyScalar(intensity * 5 + Math.random() * 5) // Add randomness
                    );
                }
            });
            if (!this.isRunning) this.start();

            // Reset auto-stop timer on kick
            clearTimeout(this.autoStopTimeout);
            this.autoStopTimeout = setTimeout(() => {
                // Check energy again before stopping, might have been kicked again
                if (this.isRunning && this.energy < this.settings.minEnergyThreshold) {
                    this.stop();
                }
            }, this.settings.autoStopDelay);
        }

        _calculateStep() {
            if (this.nodes.length < 2) return 0;
            let totalEnergy = 0;
            const forces = new Map(this.nodes.map(node => [node.id, new THREE.Vector3()]));
            const {
                repulsion,
                attraction,
                idealEdgeLength,
                centerStrength,
                gravityCenter,
                zSpreadFactor
            } = this.settings;

            // Repulsion (Node size aware)
            for (let i = 0; i < this.nodes.length; i++) {
                const nodeA = this.nodes[i];
                for (let j = i + 1; j < this.nodes.length; j++) {
                    const nodeB = this.nodes[j];
                    const delta = nodeB.position.clone().sub(nodeA.position);
                    let distSq = delta.lengthSq();
                    if (distSq < 1) {
                        distSq = 1;
                        delta.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
                    }
                    const dist = Math.sqrt(distSq);

                    // Consider nodes as approximate circles/spheres for repulsion distance
                    const radiusA = Math.sqrt(nodeA.size.width * nodeA.size.height) / 2;
                    const radiusB = Math.sqrt(nodeB.size.width * nodeB.size.height) / 2;
                    const combinedRadius = (radiusA + radiusB) * 1.1; // Add 10% buffer
                    const overlap = combinedRadius - dist;

                    let forceMag = -repulsion / distSq; // Basic repulsion

                    if (overlap > 0) {
                        // Stronger repulsion if overlapping, proportional to overlap squared for faster separation
                        forceMag -= (repulsion * Math.pow(overlap, 2) * 0.01) / dist;
                    }

                    const forceVec = delta.normalize().multiplyScalar(forceMag);
                    forceVec.z *= zSpreadFactor;

                    forces.get(nodeA.id).add(forceVec);
                    forces.get(nodeB.id).sub(forceVec);
                }
            }

            // Attraction (Edges)
            this.edges.forEach(edge => {
                const {source, target} = edge;
                if (!source || !target) return; // Skip if edge is invalid
                const delta = target.position.clone().sub(source.position);
                const dist = delta.length() + 0.1; // Add epsilon to avoid division by zero
                const effectiveIdealLength = idealEdgeLength * (edge.data.constraint === 'tight' ? 0.7 : (edge.data.constraint === 'loose' ? 1.3 : 1.0));
                const displacement = dist - effectiveIdealLength;
                const forceMag = attraction * displacement;
                const forceVec = delta.normalize().multiplyScalar(forceMag);
                forceVec.z *= zSpreadFactor;

                if (!this.fixedNodes.has(source)) forces.get(source.id)?.add(forceVec);
                if (!this.fixedNodes.has(target)) forces.get(target.id)?.sub(forceVec);
            });

            // Center Gravity
            if (centerStrength > 0) {
                this.nodes.forEach(node => {
                    const forceVec = gravityCenter.clone().sub(node.position).multiplyScalar(centerStrength);
                    forceVec.z *= zSpreadFactor * 0.5;
                    forces.get(node.id)?.add(forceVec);
                });
            }

            // Apply forces
            this.nodes.forEach(node => {
                if (this.fixedNodes.has(node)) return;
                const force = forces.get(node.id);
                const velocity = this.velocities.get(node.id);
                if (!force || !velocity) return; // Skip if data is missing

                velocity.add(force).multiplyScalar(this.settings.damping);

                // Limit velocity to prevent explosion
                const speed = velocity.length();
                if (speed > 50) velocity.multiplyScalar(50 / speed);

                node.position.add(velocity);
                totalEnergy += velocity.lengthSq();
            });

            return totalEnergy;
        }
    }

    // --- Initialization ---
    function init() {
        const container = $('#mindmap-container');
        const statusIndicator = $('#status-indicator');
        if (!container) throw new Error("Mind map container not found!");

        const mindMap = new MindMap(container);
        const cameraController = new Camera(mindMap.camera, container); // Controls listen on main container
        mindMap.cameraController = cameraController;
        const forceLayout = new ForceLayout(mindMap);
        mindMap.layoutEngine = forceLayout;

        mindMap.uiManager = new UIManager(mindMap); // Initialize UI Manager AFTER core components

        mindMap.centerView(null, 0); // Center immediately
        cameraController.setInitialState(); // Set initial state AFTER first positioning

        forceLayout.runOnce(200); // Initial layout settling
        forceLayout.start(); // Keep layout subtly active

        exampleMindMap(mindMap);

        function animate() {
            // Layout step handled by forceLayout.start() -> requestAnimationFrame
            mindMap.update(); // Update node/edge visuals based on positions
            // Camera update handled by cameraController.update() -> requestAnimationFrame
            mindMap.render();
            requestAnimationFrame(animate); // Keep main render loop separate
        }

        animate();

        statusIndicator.textContent = 'Ready âœ¨';
        setTimeout(() => statusIndicator.classList.add('hidden'), 1500);

        // Expose mindMap for debugging
        window.mindMap = mindMap;
    }

    function exampleMindMap(mindMap) {
        const colors = ['#2a2a50', '#2a402a', '#402a2a', '#40402a', '#2a4040', '#402a40'];
        let colorIndex = 0;
        const nextColor = () => colors[colorIndex++ % colors.length];

        // Core Node
        const n1 = mindMap.addNode(new NoteNode(null, {x: 0, y: 0, z: 0}, {
            content: "<h1>ðŸš€ NeuroWeaver ðŸ§ </h1><p>Enhanced Mind Map Demo</p>",
            width: 300, height: 110, backgroundColor: nextColor()
        }));

        // Features Branch
        const n_features = mindMap.addNode(new NoteNode(null, {x: 350, y: 100, z: 20}, {
            content: "<h2>Features âœ¨</h2><ul><li>Autozoom (RMB / Menu)</li><li>Node Quick Actions (Hover)</li><li>Edge Selection/Menu</li><li>Force Layout</li><li>Interactive Nodes</li></ul>",
            width: 240, height: 180, backgroundColor: nextColor()
        }));
        mindMap.addEdge(n1, n_features);

        const n_autozoom = mindMap.addNode(new NoteNode(null, {x: 600, y: 150, z: 30}, {
            content: "<h3>Autozoom Detail</h3><p>Right-click a node to zoom. Click again or use menu to go back. History stack enabled.</p>",
            width: 200, height: 120, backgroundColor: colors[1] // Reuse color
        }));
        mindMap.addEdge(n_features, n_autozoom);

        // Tech Branch
        const n_tech = mindMap.addNode(new NoteNode(null, {x: -350, y: 100, z: -10}, {
            content: "<h2>Technology ðŸ’»</h2><p><code>HTML</code> <code>CSS</code> <code>JS (ESM)</code></p><p><b>Three.js</b> + <b>CSS3DRenderer</b></p><p><b>GSAP</b> for animation</p>",
            width: 250, height: 140, backgroundColor: nextColor()
        }));
        mindMap.addEdge(n1, n_tech);

        // Style Branch
        const n_style = mindMap.addNode(new NoteNode(null, {x: 0, y: -250, z: 0}, {
            content: "<h2>Style ðŸŽ¨</h2><p>âœ¨ Minimal Dark Mode</p><p>ðŸŽ¨ Varied Node Colors</p><p>ðŸ•¸ï¸ Subtle Dot Grid</p><p>ðŸ”§ Simple CSS Vars</p>",
            width: 220, height: 140, backgroundColor: nextColor()
        }));
        mindMap.addEdge(n1, n_style);

        // Interactive Node Example
        const interactiveNodeId = generateId('interactive');
        const n_interactive = mindMap.addNode(new NoteNode(interactiveNodeId, {x: 350, y: -150, z: -30}, {
            content: `<h2>Interactive HTML</h2>
                    <p>Slider value: <span id="slider-val-${interactiveNodeId}">50</span></p>
                    <input type="range" min="0" max="100" value="50" style="width: 90%; pointer-events: auto;"
                           oninput="document.getElementById('slider-val-${interactiveNodeId}').textContent = this.value">
                    <button onclick="alert('Button inside node ${interactiveNodeId} clicked!')" style="pointer-events: auto;">Click Me</button>`,
            width: 230, height: 160, backgroundColor: nextColor()
        }));
        mindMap.addEdge(n_features, n_interactive);
        mindMap.addEdge(n_style, n_interactive); // Cross link

        // Hierarchical / Fractal Example
        const n_fractal_root = mindMap.addNode(new NoteNode(null, {x: -400, y: -200, z: 50}, {
            content: "<h3>Hierarchy</h3>", width: 120, height: 50, backgroundColor: colors[0]
        }));
        mindMap.addEdge(n_tech, n_fractal_root);

        for (let i = 0; i < 3; i++) {
            const angle = (i / 3) * Math.PI * 2;
            const n_level1 = mindMap.addNode(new NoteNode(null, {
                x: n_fractal_root.position.x + Math.cos(angle) * 150,
                y: n_fractal_root.position.y + Math.sin(angle) * 150,
                z: n_fractal_root.position.z + (Math.random() - 0.5) * 40
            }, {content: `L1-${i + 1}`, width: 80, height: 40, backgroundColor: colors[1]}));
            mindMap.addEdge(n_fractal_root, n_level1);

            for (let j = 0; j < 2; j++) {
                const angle2 = (j / 2) * Math.PI * 2 + Math.random() * 0.5;
                const n_level2 = mindMap.addNode(new NoteNode(null, {
                    x: n_level1.position.x + Math.cos(angle2) * 80,
                    y: n_level1.position.y + Math.sin(angle2) * 80,
                    z: n_level1.position.z + (Math.random() - 0.5) * 30
                }, {content: `L2-${j + 1}`, width: 60, height: 30, backgroundColor: colors[2]}));
                mindMap.addEdge(n_level1, n_level2);
            }
        }
    }

    try {
        init();
    } catch (error) {
        console.error("Initialization Failed:", error);
        const status = $('#status-indicator');
        status.textContent = `Error: ${error.message}`;
        status.style.backgroundColor = 'var(--delete-button-bg)';
        status.style.transition = 'none';
        status.classList.remove('hidden');
    }

</script>
</body>
</html>