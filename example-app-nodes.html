<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
        <title>SpaceGraph - App Node Examples</title>
        <link
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üí°</text></svg>"
            rel="icon"
        />
        <link href="index.css" rel="stylesheet" />
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <style>
            /* Styles for Markdown Editor Node (can be moved to index.css later) */
            .node-html.markdown-editor-node .editor-area {
                /* Target textarea within the specific node type */
                background-color: #2d2d2d; /* Darker background for text area */
                color: #f0f0f0; /* Light text */
                font-family: monospace;
                border: none;
                padding: 8px;
                margin: 0; /* Remove default textarea margin */
                box-sizing: border-box;
            }
            .node-html.markdown-editor-node .preview-area {
                /* Target preview div */
                background-color: #fff; /* White background for preview */
                color: #333; /* Dark text for preview */
                padding: 8px;
                overflow-y: auto;
                box-sizing: border-box;
            }
            /* Ensure node-html itself doesn't add extra padding if children handle it */
            .node-html.markdown-editor-node .node-inner-wrapper {
                padding: 0;
            }

            /* Task List Node Specific Styles */
            .task-list-node-content {
                padding: 10px;
                background-color: #f0f8ff; /* AliceBlue */
                color: #333;
                border-radius: 8px; /* Match node-html */
                font-family: var(--font-family); /* Ensure consistent font */
            }
            .task-list-node-content h3 {
                margin-top: 0;
                margin-bottom: 8px;
                text-align: center;
                color: #007bff;
            }
            .task-list-node-content .input-container {
                /* Container for input + button */
                display: flex;
                margin-bottom: 8px;
            }
            .task-list-node-content .new-task-input {
                flex-grow: 1;
                margin-right: 5px;
                padding: 5px;
                border: 1px solid #ccc;
                border-radius: 3px;
            }
            .task-list-node-content .add-task-button {
                padding: 5px 10px;
                background-color: #28a745;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
            }
            .task-list-node-content .add-task-button:hover {
                background-color: #218838;
            }
            .task-list-node-content .task-list-ul {
                list-style-type: none;
                padding: 0;
                margin-top: 0; /* No extra space above list */
                flex-grow: 1; /* Allow list to take available space */
                overflow-y: auto;
                min-height: 50px; /* Ensure it's visible even when empty */
            }
            .task-list-node-content .task-list-ul li {
                display: flex;
                align-items: center;
                padding: 6px 2px;
                border-bottom: 1px solid #eee;
            }
            .task-list-node-content .task-list-ul li:last-child {
                border-bottom: none;
            }
            .task-list-node-content .task-list-ul li input[type='checkbox'] {
                margin-right: 10px;
                cursor: pointer;
                width: 16px; /* Larger checkboxes */
                height: 16px;
            }
            .task-list-node-content .task-list-ul li span {
                /* Task text span */
                flex-grow: 1;
                word-break: break-word;
            }
            .task-list-node-content .task-list-ul li span.completed {
                text-decoration: line-through;
                color: #999;
            }
            .task-list-node-content .task-list-ul li .delete-task-button {
                margin-left: 8px; /* Space between text and button */
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 3px;
                cursor: pointer;
                padding: 3px 6px;
                font-size: 10px;
                line-height: 1;
            }
            .task-list-node-content .task-list-ul li .delete-task-button:hover {
                background: #c82333;
            }
        </style>
    </head>
    <body>
        <div id="space">
            <canvas id="webgl-canvas"></canvas>
            <div id="css3d-container"></div>
        </div>

        <div id="node-palette">
            <button id="btn-create-md-editor" draggable="true">üìù Create Markdown Editor</button>
            <button id="btn-create-task-list" draggable="true">üìã Create Task List</button>
        </div>

        <script type="importmap">
            {
                "imports": {
                    "three": "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
                    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
                    "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
                }
            }
        </script>
        <script type="module">
            // This example demonstrates the creation and usage of complex, custom "App Nodes"
            // using SpaceGraph.registerNodeType. It defines two custom node types:
            // 1. Markdown Editor: A node with a textarea for Markdown input and a live preview pane.
            //    It uses the 'marked.js' library for rendering HTML from Markdown.
            //    It also shows how to define input/output ports for inter-node communication.
            // 2. Task List: A node that manages a list of tasks with add, complete, and delete functionalities.
            //    It demonstrates dynamic HTML generation within a node and emitting events for task updates.
            import * as S from './spacegraph.js'; // Assuming spacegraph.js is in the same directory

            // --- Markdown Editor Node Definition ---
            // This object defines the behavior and appearance of our custom Markdown editor node.
            const markdownEditorNodeDefinition = {
                /**
                 * Provides default data for a new Markdown editor node.
                 * This is called when a node of this type is created.
                 * @param {object} initialData - Any data passed during node creation (e.g., from addNode or palette).
                 * @returns {object} The default data object for this node type.
                 */
                getDefaults: (initialData) => ({
                    markdownContent: initialData?.markdownContent || '# Hello\n\nStart typing Markdown here...',
                    width: initialData?.width || 350, // Default width of the node
                    height: initialData?.height || 400, // Default height of the node
                    label: initialData?.label || initialData?.id || 'Markdown Editor', // Default label
                    ports: initialData?.ports || {
                        // Define input/output ports for communication
                        inputs: { md_in: { label: 'Markdown In', type: 'string' } }, // Input port for Markdown text
                        outputs: { html_out: { label: 'HTML Out', type: 'string' } }, // Output port for rendered HTML
                    },
                }),
                /**
                 * Creates the visual representation (HTML element) of the Markdown editor node.
                 * This function is called by SpaceGraph when a node of this type is added.
                 * @param {S.RegisteredNode} nodeInst - The instance of the RegisteredNode being created.
                 * @param {S.SpaceGraph} spaceGraph - The SpaceGraph instance.
                 * @returns {object} An object containing the `htmlElement` for this node.
                 */
                onCreate: (nodeInst, spaceGraph) => {
                    // Access THREE and CSS3DObject, required if creating CSS3DObjects directly (though not strictly needed here as we return htmlElement)
                    const three = spaceGraph.constructor.THREE;
                    const CSS3DObject = three.CSS3DObject || window.CSS3DObject;

                    // Create the main container div for the node's HTML content
                    nodeInst.htmlElement = document.createElement('div');
                    nodeInst.htmlElement.classList.add('markdown-editor-node'); // Add class for specific CSS styling
                    nodeInst.htmlElement.style.width = `${nodeInst.data.width}px`;
                    nodeInst.htmlElement.style.height = `${nodeInst.data.height}px`;
                    nodeInst.htmlElement.style.backgroundColor = 'var(--node-bg-alt, #282c34)'; // Use CSS variables for theming
                    nodeInst.htmlElement.style.border = '1px solid var(--accent-color-darker, #444)';
                    nodeInst.htmlElement.style.display = 'flex';
                    nodeInst.htmlElement.style.flexDirection = 'column'; // Stack editor and preview vertically
                    nodeInst.htmlElement.style.overflow = 'hidden'; // Prevent content from spilling out

                    // Create the textarea for Markdown input
                    const editor = document.createElement('textarea');
                    editor.className = 'editor-area'; // For specific styling (see <style> block in HTML head)
                    editor.style.flex = '1'; // Allow editor to take up half the space
                    editor.style.resize = 'none'; // Disable manual resize of textarea
                    editor.value = nodeInst.data.markdownContent; // Set initial content from node data
                    editor.spellcheck = false;

                    // Create the div for HTML preview
                    const preview = document.createElement('div');
                    preview.className = 'preview-area'; // For specific styling
                    preview.style.flex = '1'; // Allow preview to take up the other half
                    preview.style.borderTop = '1px solid #444'; // Separator line

                    // Append editor and preview areas to the node's main HTML element
                    nodeInst.htmlElement.appendChild(editor);
                    nodeInst.htmlElement.appendChild(preview);

                    /**
                     * Renders the Markdown content from `nodeInst.data.markdownContent` into the preview div.
                     * Uses the `marked.js` library (expected to be globally available).
                     * Emits the rendered HTML to the 'html_out' output port.
                     */
                    const renderPreview = () => {
                        if (window.marked && typeof window.marked.parse === 'function') {
                            preview.innerHTML = window.marked.parse(nodeInst.data.markdownContent);
                        } else {
                            preview.textContent = 'Marked.js not loaded or .parse not a function.';
                            console.warn('Marked.js not loaded or marked.parse is not a function.');
                        }
                        // Emit the HTML content to the output port if defined
                        if (nodeInst.data.ports?.outputs?.html_out) {
                            // `nodeInst.emit(portName, payload)` sends data from this node's output port.
                            nodeInst.emit('html_out', preview.innerHTML);
                        }
                    };

                    // IMPORTANT: Stop pointer events (like drag, click) on the editor and preview areas
                    // from propagating to the SpaceGraph's UIManager. This allows normal text interaction
                    // (selection, scrolling) without accidentally dragging the node or triggering graph-level events.
                    editor.addEventListener('pointerdown', (e) => e.stopPropagation());
                    preview.addEventListener('pointerdown', (e) => e.stopPropagation());
                    // Also stop wheel events inside these areas from affecting camera zoom.
                    editor.addEventListener('wheel', (e) => e.stopPropagation());
                    preview.addEventListener('wheel', (e) => e.stopPropagation());

                    // Listen for input in the editor textarea to update Markdown content and re-render preview
                    editor.addEventListener('input', () => {
                        nodeInst.data.markdownContent = editor.value; // Update node's internal data
                        renderPreview(); // Re-render the preview and emit HTML
                    });

                    renderPreview(); // Initial render of the Markdown content when the node is created

                    // Store references to key internal elements on `nodeInst.customElements`.
                    // This allows `onDataUpdate` or other methods to access and manipulate them later.
                    nodeInst.customElements = { editor, preview, renderPreview };

                    // Return the main htmlElement. SpaceGraph's RegisteredNode class will automatically
                    // wrap this in a CSS3DObject for rendering in the 3D scene.
                    return { htmlElement: nodeInst.htmlElement };
                },
                /**
                 * Calculates the bounding sphere radius for this node type.
                 * Used for camera focusing and layout calculations.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 * @returns {number} The bounding sphere radius.
                 */
                getBoundingSphereRadius: (nodeInst) => {
                    // Approximate based on the diagonal of the node's dimensions
                    return Math.sqrt(nodeInst.data.width ** 2 + nodeInst.data.height ** 2) / 2;
                },
                /**
                 * Cleans up resources when the node is disposed.
                 * For this node, there are no specific Three.js objects created directly by `onCreate`
                 * that need manual disposal (like geometries or materials).
                 * Event listeners on `editor` and `preview` are on children of `nodeInst.htmlElement`,
                 * and will be removed from the DOM when `nodeInst.htmlElement` is removed by the base `RegisteredNode.dispose()`.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 */
                onDispose: (nodeInst) => {
                    nodeInst.customElements = null; // Clear references to custom elements
                },
                /**
                 * Handles external updates to the node's data.
                 * This method is called if `space.updateNodeData(nodeId, { ... })` is used,
                 * or if data arrives through an input port that is configured to update `nodeInst.data`.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 * @param {object} updatedData - The new data that was received.
                 */
                onDataUpdate: (nodeInst, updatedData) => {
                    // Check if 'markdownContent' was part of the updated data
                    if (updatedData.markdownContent !== undefined && nodeInst.customElements?.editor) {
                        // Only update if the content has actually changed to avoid unnecessary re-renders or cursor jumps
                        if (nodeInst.customElements.editor.value !== updatedData.markdownContent) {
                            nodeInst.customElements.editor.value = updatedData.markdownContent; // Update the textarea
                            nodeInst.customElements.renderPreview(); // Re-render the preview
                        }
                    }
                },
            };

            // --- Task List Node Definition ---
            // Defines a custom node for managing a to-do list.
            const taskListNodetypeDefinition = {
                /**
                 * Provides default data for a new Task List node.
                 * @param {object} initialData - Data passed during node creation.
                 * @returns {object} Default data object.
                 */
                getDefaults: (initialData) => ({
                    tasks: initialData?.tasks || [{ id: 'task-init-1', text: 'First task', completed: false }], // Default tasks
                    width: initialData?.width || 300,
                    height: initialData?.height || 280,
                    title: initialData?.title || 'My To-Do List', // Default title for the list
                    label: initialData?.label || initialData?.id || 'Task List',
                    ports: initialData?.ports || {
                        // Define input/output ports
                        inputs: { add_task: { label: 'Add Task (text)', type: 'string' } }, // Input port to add a new task
                        outputs: {
                            task_completed: { label: 'Task Completed (taskObj)', type: 'object' }, // Output port for completed tasks
                            tasks_updated: { label: 'Tasks Updated (allTasks)', type: 'array' }, // Output port when the list changes
                        },
                    },
                }),
                /**
                 * Creates the HTML structure for the Task List node.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 * @param {S.SpaceGraph} spaceGraph - The SpaceGraph instance.
                 * @returns {object} An object containing the `htmlElement`.
                 */
                onCreate: (nodeInst, spaceGraph) => {
                    const three = spaceGraph.constructor.THREE;
                    const CSS3DObject = three.CSS3DObject || window.CSS3DObject;

                    // Main container for the task list UI
                    nodeInst.htmlElement = document.createElement('div');
                    nodeInst.htmlElement.classList.add('task-list-node-content'); // For specific CSS styling
                    nodeInst.htmlElement.style.width = `${nodeInst.data.width}px`;
                    nodeInst.htmlElement.style.height = `${nodeInst.data.height}px`;
                    nodeInst.htmlElement.style.display = 'flex';
                    nodeInst.htmlElement.style.flexDirection = 'column';
                    nodeInst.htmlElement.style.overflow = 'hidden'; // Important for managing internal scrolling

                    // Title element for the task list
                    const titleEl = document.createElement('h3');
                    titleEl.textContent = nodeInst.data.title;

                    // Container for the new task input field and add button
                    const inputContainer = document.createElement('div');
                    inputContainer.className = 'input-container';

                    const newTaskInput = document.createElement('input');
                    newTaskInput.type = 'text';
                    newTaskInput.placeholder = 'New task...';
                    newTaskInput.className = 'new-task-input';

                    const addTaskButton = document.createElement('button');
                    addTaskButton.textContent = 'Add';
                    addTaskButton.className = 'add-task-button';

                    inputContainer.appendChild(newTaskInput);
                    inputContainer.appendChild(addTaskButton);

                    // Unordered list (<ul>) to display the tasks
                    const taskListUl = document.createElement('ul');
                    taskListUl.className = 'task-list-ul';

                    // Assemble the HTML structure
                    nodeInst.htmlElement.appendChild(titleEl);
                    nodeInst.htmlElement.appendChild(inputContainer);
                    nodeInst.htmlElement.appendChild(taskListUl);

                    // IMPORTANT: Stop pointer events on interactive elements within the node
                    // to prevent interference with SpaceGraph's UIManager (e.g., node dragging).
                    [titleEl, newTaskInput, addTaskButton, taskListUl].forEach((el) => {
                        el.addEventListener('pointerdown', (e) => e.stopPropagation());
                        el.addEventListener('wheel', (e) => e.stopPropagation()); // Also prevents graph zoom while scrolling list
                    });

                    /**
                     * Renders the list of tasks in the `taskListUl` element.
                     * Clears existing tasks and rebuilds the list based on `nodeInst.data.tasks`.
                     * Attaches event listeners for checkbox changes (task completion) and task deletion.
                     * Emits `tasks_updated` event after rendering.
                     */
                    const renderTasks = () => {
                        taskListUl.innerHTML = ''; // Clear current task list items
                        if (!Array.isArray(nodeInst.data.tasks)) nodeInst.data.tasks = []; // Ensure tasks is an array

                        nodeInst.data.tasks.forEach((task) => {
                            const li = document.createElement('li');

                            // Checkbox for task completion
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.checked = task.completed;
                            checkbox.addEventListener('change', () => {
                                task.completed = checkbox.checked; // Update task state in node's data
                                // If a task is completed and the output port is defined, emit an event
                                if (task.completed && nodeInst.data.ports?.outputs?.task_completed) {
                                    nodeInst.emit('task_completed', { ...task }); // Emit a copy of the task object
                                }
                                renderTasks(); // Re-render the list to reflect changes (e.g., strikethrough)
                            });

                            // Span for task text
                            const span = document.createElement('span');
                            span.textContent = task.text;
                            if (task.completed) {
                                span.classList.add('completed'); // Apply 'completed' style (strikethrough)
                            }

                            // Delete button for each task
                            const deleteButton = document.createElement('button');
                            deleteButton.textContent = 'X'; // Simple delete button
                            deleteButton.className = 'delete-task-button';
                            deleteButton.addEventListener('click', () => {
                                nodeInst.data.tasks = nodeInst.data.tasks.filter((t) => t.id !== task.id); // Remove task from data
                                renderTasks(); // Re-render the list
                            });

                            li.appendChild(checkbox);
                            li.appendChild(span);
                            li.appendChild(deleteButton);
                            taskListUl.appendChild(li);
                        });

                        // Emit an event indicating the tasks list has been updated, if the port is defined
                        if (nodeInst.data.ports?.outputs?.tasks_updated) {
                            nodeInst.emit('tasks_updated', [...nodeInst.data.tasks]); // Emit a copy of the tasks array
                        }
                    };

                    // Event listener for the "Add Task" button
                    addTaskButton.addEventListener('click', () => {
                        const text = newTaskInput.value.trim();
                        if (text) {
                            // Only add task if text is not empty
                            if (!Array.isArray(nodeInst.data.tasks)) nodeInst.data.tasks = [];
                            nodeInst.data.tasks.push({ id: 'task-' + Date.now(), text: text, completed: false });
                            newTaskInput.value = ''; // Clear the input field
                            renderTasks(); // Re-render the list
                        }
                    });

                    // Allow adding tasks by pressing Enter in the input field
                    newTaskInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            addTaskButton.click(); // Simulate button click
                            e.preventDefault(); // Prevent default form submission behavior if applicable
                        }
                    });

                    renderTasks(); // Initial rendering of tasks
                    // Store key elements for potential future access (e.g., in onDataUpdate)
                    nodeInst.customElements = { titleEl, taskListUl, renderTasks, newTaskInput };
                    return { htmlElement: nodeInst.htmlElement }; // Return the main HTML element
                },
                /**
                 * Handles external updates to the node's data, such as receiving new tasks
                 * or a new title, or a direct command to add a task via the 'add_task' input port.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 * @param {object} updatedData - The new data.
                 */
                onDataUpdate: (nodeInst, updatedData) => {
                    let needsRender = false;
                    // If 'tasks' array is provided in updatedData, replace the current tasks
                    if (updatedData.tasks !== undefined) {
                        // Basic check to see if tasks actually changed to avoid unnecessary re-renders
                        if (JSON.stringify(nodeInst.data.tasks) !== JSON.stringify(updatedData.tasks)) {
                            nodeInst.data.tasks = Array.isArray(updatedData.tasks) ? [...updatedData.tasks] : [];
                            needsRender = true;
                        }
                    }
                    // If 'title' is provided, update the title element
                    if (updatedData.title !== undefined && nodeInst.customElements?.titleEl) {
                        if (nodeInst.customElements.titleEl.textContent !== updatedData.title) {
                            nodeInst.customElements.titleEl.textContent = updatedData.title;
                            nodeInst.data.title = updatedData.title; // Also update the internal data representation
                        }
                    }
                    // If 'add_task' (our defined input port name) is a string in updatedData, add it as a new task
                    if (typeof updatedData.add_task === 'string') {
                        const text = updatedData.add_task.trim();
                        if (text) {
                            // Ensure the task text is not empty
                            if (!Array.isArray(nodeInst.data.tasks)) nodeInst.data.tasks = [];
                            nodeInst.data.tasks.push({ id: 'task-' + Date.now(), text: text, completed: false });
                            needsRender = true;
                        }
                        // It's good practice to "consume" data received via input ports if it represents a one-time action.
                        // If updatedData could be a direct reference to nodeInst.data, you might do:
                        // delete nodeInst.data.add_task;
                        // However, SpaceGraph's default port-to-data mapping creates a new updatedData object,
                        // so this specific deletion isn't strictly necessary here as the value won't persist in nodeInst.data unless explicitly set.
                    }

                    // If any changes occurred that require re-rendering the task list
                    if (needsRender && nodeInst.customElements?.renderTasks) {
                        nodeInst.customElements.renderTasks();
                    }
                },
                /**
                 * Calculates the bounding sphere radius for layout and focusing.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 * @returns {number} The bounding sphere radius.
                 */
                getBoundingSphereRadius: (nodeInst) => {
                    return Math.sqrt(nodeInst.data.width ** 2 + nodeInst.data.height ** 2) / 2;
                },
                /**
                 * Cleans up when the node is disposed.
                 * @param {S.RegisteredNode} nodeInst - The node instance.
                 */
                onDispose: (nodeInst) => {
                    nodeInst.customElements = null; // Clear references
                },
            };

            // --- Initialization Function ---
            // Sets up the SpaceGraph instance, registers custom node types,
            // adds initial nodes, and sets up inter-node communication examples.
            function init() {
                const container = S.$('#space');
                if (!container) {
                    console.error('Initialization Failed: Missing required #space container element.');
                    return;
                }

                try {
                    const space = new S.SpaceGraph(container);
                    window.space = space; // Make it globally accessible for easy debugging from the console

                    // Register the custom node type definitions with SpaceGraph.
                    // The first argument is the type name (string) used when adding nodes.
                    // The second argument is the TypeDefinition object.
                    space.registerNodeType('markdown-editor', markdownEditorNodeDefinition);
                    space.registerNodeType('task-list', taskListNodetypeDefinition);

                    // Add initial instances of our custom nodes to the graph.
                    const mdEditor1 = space.addNode({
                        type: 'markdown-editor', // Use the registered type name
                        id: 'md-editor-1', // Unique ID for this node
                        x: -250,
                        y: 0,
                        z: 0, // Initial position
                    });

                    const taskNode1 = space.addNode({
                        type: 'task-list',
                        id: 'tasks-1',
                        x: 200,
                        y: -150,
                        z: 0,
                        data: {
                            // Custom data for this specific instance of task-list
                            title: 'Project Bravo Tasks',
                            tasks: [
                                { id: 'task-a', text: 'Design phase for Bravo', completed: true },
                                { id: 'task-b', text: 'Bravo Implementation', completed: false },
                                { id: 'task-c', text: 'Testing & QA for Bravo', completed: false },
                            ],
                        },
                    });

                    // Create a simple listener node (using the built-in 'note' type)
                    // to demonstrate receiving data from the Markdown editor's 'html_out' port.
                    const listenerNode = space.addNode({
                        type: 'note',
                        id: 'html-listener-1',
                        x: 200,
                        y: 150,
                        z: 0, // Positioned to receive from mdEditor1
                        width: 300,
                        height: 250,
                        content: 'Waiting for HTML output from Markdown Editor...',
                    });

                    // --- Inter-node Communication Example: Markdown Editor to Listener Node ---
                    if (mdEditor1 && listenerNode) {
                        // Get the actual instance of the listener node (SpaceGraph.addNode returns the instance directly)
                        const listenerNodeInstance = listenerNode; // listenerNode is already the instance

                        // INCORRECT USAGE (kept for illustrative comment, then corrected below):
                        // mdEditor1.listenTo('html-listener-1', 'html_out', (htmlPayload, senderNode) => {
                        //    // This callback setup is conceptually wrong. The LISTENER node should be the one calling listenTo.
                        // });

                        // CORRECTED USAGE: The listenerNodeInstance calls `listenTo`, specifying the sender (mdEditor1)
                        // and the port name ('html_out') on the sender to listen to.
                        // `listenTo` sets up an internal mechanism where listenerNodeInstance will react to 'html_out' events from mdEditor1.
                        listenerNodeInstance.listenTo(
                            mdEditor1, // The sender node instance to listen to
                            'html_out', // The name of the output port on mdEditor1 to listen to
                            (htmlPayload, senderNode) => {
                                // Callback function when data is received
                                console.log(
                                    `Listener node ${listenerNodeInstance.id} received HTML from ${senderNode.id}.`
                                );
                                // Update the content of the listener NoteNode.
                                // NoteNode uses 'content' in its `data` object to store its display HTML.
                                listenerNodeInstance.data.content = htmlPayload;
                                // For a NoteNode (or any HtmlNodeElement), to make the change visible,
                                // its internal HTML also needs to be updated.
                                const contentDiv = listenerNodeInstance.htmlElement?.querySelector('.node-content');
                                if (contentDiv) contentDiv.innerHTML = htmlPayload;
                            }
                        );
                        console.log(
                            `Node ${listenerNodeInstance.id} is now listening to 'html_out' events from ${mdEditor1.id}`
                        );
                    }

                    // --- Inter-node Communication Example: Task List to Listener Node ---
                    // Reusing listenerNode for simplicity to also listen to taskNode1's 'tasks_updated' port.
                    if (taskNode1 && listenerNode) {
                        const taskListenerNodeInstance = listenerNode; // Reusing the same listener node instance

                        // CORRECTED USAGE: taskListenerNodeInstance listens to taskNode1's 'tasks_updated' output port.
                        taskListenerNodeInstance.listenTo(
                            taskNode1, // The sender node instance (Task List)
                            'tasks_updated', // The name of the output port on taskNode1
                            (tasksPayload, senderNode) => {
                                // Callback when tasks are updated
                                console.log(
                                    `Listener node ${taskListenerNodeInstance.id} received 'tasks_updated' from ${senderNode.id}:`,
                                    tasksPayload
                                );
                                // Display the received task list in the listener node.
                                let content = `<h3>Tasks from ${senderNode.id} (${senderNode.data.title || ''})</h3><ul>`;
                                tasksPayload.forEach((task) => {
                                    content += `<li>${task.text} (${task.completed ? 'Done' : 'Pending'})</li>`;
                                });
                                content += `</ul>`;
                                taskListenerNodeInstance.data.content = content; // Update data
                                const contentDiv = taskListenerNodeInstance.htmlElement?.querySelector('.node-content');
                                if (contentDiv) contentDiv.innerHTML = content; // Update HTML view
                            }
                        );
                        console.log(
                            `Node ${taskListenerNodeInstance.id} is now listening to 'tasks_updated' events from ${taskNode1.id}`
                        );

                        // Example of sending data TO the 'add_task' input port of taskNode1.
                        // This is typically done from another node or an external trigger.
                        // Here, we simulate it with a timeout.
                        // The `space.updateNodeData` method will trigger the `onDataUpdate` callback
                        // in the taskListNodetypeDefinition if the 'add_task' port is configured
                        // (implicitly or explicitly) to update the node's data.
                        setTimeout(() => {
                            console.log("Attempting to add task to taskNode1 via its 'add_task' input port...");
                            // This sends data to the 'add_task' input port of taskNode1.
                            // The Task List node's onDataUpdate method is designed to handle this.
                            space.updateNodeData(taskNode1.id, { add_task: 'Task added via updateNodeData!' });

                            // Alternative ways to send data or trigger actions (for conceptual understanding):
                            // 1. If taskNode1 was directly listening for an event named 'add_task':
                            //    taskNode1.emit('add_task', "A task from taskNode1 listening to itself");
                            //
                            // 2. If another node (e.g., someOtherNode) wanted to send data to taskNode1's 'add_task' port:
                            //    (Assuming someOtherNode is an instance of a RegisteredNode with emitTo capability)
                            //    someOtherNode.emitTo(taskNode1.id, 'add_task', "Task sent from another node's emitTo");
                            //
                            // 3. Direct data manipulation (less recommended for triggering port logic, but possible):
                            //    taskNode1.data.add_task = "New task by direct data manipulation";
                            //    // This would require taskNode1.onDataUpdate to be called, possibly manually or by a graph refresh.
                            //    // space.nodeNeedsUpdate(taskNode1); // Or similar mechanism if available.
                        }, 5000);
                    }

                    // --- Palette Setup for Drag-and-Drop Node Creation ---
                    // Get the button for creating Markdown editors
                    const mdPaletteBtn = S.$('#btn-create-md-editor');
                    if (mdPaletteBtn) {
                        // Add event listener for when dragging starts from this button
                        mdPaletteBtn.addEventListener('dragstart', (event) => {
                            // Data to be associated with the new node when dropped
                            const nodeData = {
                                type: 'markdown-editor', // Must match a registered node type
                                label: 'Markdown Editor (D&D)', // Custom label for the new node
                                // Other default data can be included here
                            };
                            // Set the drag effect (visual feedback)
                            event.dataTransfer.effectAllowed = 'copy';
                            // Set the data being dragged, using a custom type for SpaceGraph to recognize
                            event.dataTransfer.setData('application/x-spacegraph-node-type', JSON.stringify(nodeData));
                        });
                    }

                    // Get the button for creating Task Lists
                    const taskPaletteBtn = S.$('#btn-create-task-list');
                    if (taskPaletteBtn) {
                        // Add event listener for when dragging starts
                        taskPaletteBtn.addEventListener('dragstart', (event) => {
                            const nodeData = {
                                type: 'task-list',
                                label: 'To-Dos (D&D)',
                                data: { title: 'New List (D&D)' }, // Initial data for this specific node type
                            };
                            event.dataTransfer.effectAllowed = 'copy';
                            event.dataTransfer.setData('application/x-spacegraph-node-type', JSON.stringify(nodeData));
                        });
                    }

                    // Perform initial layout and center the view
                    space.layoutEngine.runOnce(100);
                    space.centerView(); // Center the camera on the graph content

                    // Display a status message
                    const statusEl =
                        S.$('#status-indicator') || document.body.appendChild(document.createElement('div'));
                    statusEl.id = 'status-indicator'; // Ensure it has an ID if newly created
                    statusEl.textContent =
                        'App Node Example Initialized. Custom nodes (Markdown Editor, Task List) are registered and added.';
                    setTimeout(() => statusEl.classList.add('hidden'), 3000); // Hide after 3 seconds
                } catch (error) {
                    console.error('App Node Example Initialization Failed:', error);
                    // Display error message in the container if initialization fails
                    container.innerHTML = `<div style="color: red; padding: 20px;">Error initializing SpaceGraph App Node Example: ${error.message}<br><pre>${error.stack}</pre></div>`;
                }
            }

            // Ensure DOM is fully loaded before running the init function
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                init(); // DOM is already loaded
            }
        </script>
    </body>
</html>
