import * as THREE from 'three';
import { generateId } from './utils.js';

/**
 * @class BaseNode
 * @classdesc Abstract base class for all node types within a {@link SpaceGraph}.
 * It defines the common interface and core functionalities inherited by all specialized node classes,
 * such as managing position, data, unique identification, and basic lifecycle methods (update, dispose).
 *
 * `BaseNode` instances are typically not created directly. Instead, subclasses like
 * {@link HtmlNodeElement}, {@link ShapeNode}, or {@link RegisteredNode} are instantiated.
 *
 * @property {string} id - Unique identifier for the node. Automatically generated (e.g., `node-timestamp-random`)
 *                         if not provided in the constructor data.
 * @property {import('../spacegraph.js').SpaceGraph | null} spaceGraph - Reference to the parent {@link SpaceGraph} instance.
 *                                          This is set when the node is added to the graph via {@link SpaceGraph#addNode}.
 * @property {THREE.Vector3} position - The current 3D position of the node in world space.
 *                                      Managed by the {@link ForceLayout} engine or direct manipulation.
 * @property {object} data - An object containing arbitrary data associated with the node.
 *                           The structure of this data often includes properties like `label`, `type`,
 *                           and other attributes specific to the node's type or application requirements (e.g., `content` for notes, `shape` for shapes).
 *                           This is typically initialized from {@link NodeDataObject} upon creation.
 * @property {number} mass - Mass of the node, used by the {@link ForceLayout} engine for physics simulations.
 *                           Must be a positive value. Default is `1.0`.
 * @property {THREE.Mesh | null} mesh - Optional Three.js {@link THREE.Mesh} for WebGL-rendered visual representation of the node.
 *                                      Primarily used by {@link ShapeNode} and custom {@link RegisteredNode}s that create WebGL visuals.
 * @property {import('three/addons/renderers/CSS3DRenderer.js').CSS3DObject | null} cssObject - Optional Three.js {@link CSS3DObject} used for rendering an `htmlElement`
 *                                           as part of the 3D scene. Utilized by {@link HtmlNodeElement} and {@link RegisteredNode}s with HTML content.
 * @property {HTMLElement | null} htmlElement - Optional underlying {@link HTMLElement} associated with `cssObject`.
 *                                            This is the actual DOM element that gets rendered in 3D space.
 * @property {import('three/addons/renderers/CSS3DRenderer.js').CSS3DObject | null} labelObject - Optional {@link CSS3DObject} for rendering a text label associated with the node,
 *                                             typically used by {@link ShapeNode}s or custom nodes requiring separate 3D labels.
 */
export class BaseNode {
    /** @type {string} */
    id = null;
    /** @type {import('../spacegraph.js').SpaceGraph | null} */
    spaceGraph = null;
    /** @type {THREE.Vector3} */
    position = new THREE.Vector3();
    /** @type {object} */
    data = {};
    /** @type {number} */
    mass = 1.0;
    /** @type {THREE.Mesh | null} */
    mesh = null;
    /** @type {import('three/addons/renderers/CSS3DRenderer.js').CSS3DObject | null} */
    cssObject = null;
    /** @type {HTMLElement | null} */
    htmlElement = null;
    /** @type {import('three/addons/renderers/CSS3DRenderer.js').CSS3DObject | null} */
    labelObject = null;

    /**
     * Constructs a BaseNode instance.
     * As `BaseNode` is an abstract class, this constructor is typically called via `super()` from a subclass constructor.
     * It initializes the node's ID, position, data (merging with defaults), and mass.
     *
     * @constructor
     * @param {string | null} id - Unique ID for the node. If `null` or `undefined`, a new ID will be generated by {@link generateId}.
     * @param {{x: number, y: number, z: number}} [position={x:0,y:0,z:0}] - Initial 3D position of the node in world space.
     * @param {object} [data={}] - Initial data for the node. This will be merged with default data provided by the node type's `getDefaultData()` method.
     *                             See {@link NodeDataObject} for common properties.
     * @param {number} [mass=1.0] - Mass of the node for physics calculations by {@link ForceLayout}. Must be positive (clamped to a minimum of 0.1).
     * @example
     * // Called from a subclass constructor:
     * // super(id, position, { ...myData, ...data }, mass);
     */
    constructor(id, position = { x: 0, y: 0, z: 0 }, data = {}, mass = 1.0) {
        this.id = id ?? generateId('node');
        this.position.set(position.x ?? 0, position.y ?? 0, position.z ?? 0); // Ensure x,y,z defaults if not in position object
        this.data = { ...this.getDefaultData(), ...data }; // Merge provided data with defaults
        this.mass = Math.max(0.1, mass); // Ensure mass is positive and non-zero
    }

    /**
     * Provides default data for a node. Subclasses should override this method
     * to define their specific default properties (e.g., type-specific attributes like `content`, `shape`, `size`).
     * The object returned by this method is merged with the `data` provided in the constructor,
     * with the constructor's data taking precedence.
     *
     * @returns {object} An object containing default data properties.
     *                   The base implementation returns an object with a `label` property set to the node's `id`.
     * @protected
     * @example
     * // In a subclass like ShapeNode:
     * getDefaultData() {
     *   return {
     *     ...super.getDefaultData(), // Includes label: this.id
     *     type: 'shape',
     *     shape: 'sphere',
     *     size: 50,
     *     color: 0xffffff
     *   };
     * }
     */
    getDefaultData() {
        return { label: this.id };
    }

    /**
     * Sets the 3D position of the node in world space.
     * Subclasses are expected to override this method to also update the positions
     * of their specific visual components (e.g., `this.mesh.position`, `this.cssObject.position`).
     * The base method only updates `this.position`.
     *
     * @param {number} x - The new x-coordinate in world space.
     * @param {number} y - The new y-coordinate in world space.
     * @param {number} z - The new z-coordinate in world space.
     * @example
     * myNode.setPosition(100, 50, -20);
     */
    setPosition(x, y, z) {
        this.position.set(x, y, z);
        // Subclasses should update their visual objects here, e.g.:
        // if (this.mesh) this.mesh.position.copy(this.position);
        // if (this.cssObject) this.cssObject.position.copy(this.position);
    }

    /**
     * Abstract method intended to be called by {@link SpaceGraph#_animate} (the main animation loop) via {@link SpaceGraph#_updateNodesAndEdges}.
     * Subclasses must implement this method to update their state, position, orientation,
     * or any other dynamic aspects of the node (e.g., making an HTML node face the camera if billboarded).
     *
     * @param {import('../spacegraph.js').SpaceGraph} spaceGraphInstance - Reference to the parent {@link SpaceGraph} instance,
     *                                          providing access to global graph properties like the camera ({@link SpaceGraph#_camera}).
     * @abstract
     * @example
     * // In a subclass like HtmlNodeElement:
     * update(spaceGraphInstance) {
     *   if (this.cssObject) {
     *     this.cssObject.position.copy(this.position); // Update CSS3DObject position
     *     if (this.billboard && spaceGraphInstance?._camera) { // If billboard is true
     *       this.cssObject.quaternion.copy(spaceGraphInstance._camera.quaternion); // Face the camera
     *     }
     *   }
     * }
     */
    update(spaceGraphInstance) {
        // Base implementation does nothing.
        // Subclasses override this to update visuals, e.g.:
        // if (this.cssObject && this.billboard) {
        //   this.cssObject.quaternion.copy(spaceGraphInstance._camera.quaternion);
        // }
        // if (this.mesh) this.mesh.position.copy(this.position);
    }

    /**
     * Cleans up resources used by the node. This is crucial for preventing memory leaks when nodes are removed
     * from the graph via {@link SpaceGraph#removeNode}.
     * Subclasses **must** override this method to dispose of their specific Three.js objects
     * (geometries, materials, textures), remove any DOM elements they created, and detach event listeners.
     *
     * The base implementation handles disposal of `this.mesh` (and its geometry/material),
     * `this.cssObject` (and its element), and `this.labelObject` (and its element).
     * It also clears the reference to `this.spaceGraph`.
     *
     * @example
     * // In a subclass with custom resources:
     * dispose() {
     *   // Dispose custom Three.js objects
     *   this.myCustomMesh?.geometry?.dispose();
     *   this.myCustomMesh?.material?.dispose();
     *   this.myCustomMesh?.parent?.remove(this.myCustomMesh);
     *   // Remove custom DOM elements
     *   this.myCustomDiv?.remove();
     *   // Remove custom event listeners
     *   window.removeEventListener('mousemove', this.myMouseMoveListener);
     *
     *   super.dispose(); // **Important**: Call super.dispose() to clean up common resources
     * }
     */
    dispose() {
        // Dispose WebGL mesh resources
        if (this.mesh) {
            this.mesh.parent?.remove(this.mesh); // Remove from scene graph
            this.mesh.geometry?.dispose();
            // Material disposal: check if material is an array (multi-material) or single
            if (Array.isArray(this.mesh.material)) {
                this.mesh.material.forEach((m) => m.dispose());
            } else if (this.mesh.material) {
                this.mesh.material.dispose();
            }
            this.mesh = null;
        }

        // Dispose CSS3DObject and its underlying HTML element
        if (this.cssObject) {
            this.cssObject.parent?.remove(this.cssObject); // Remove from CSS3D scene
            this.cssObject.element?.remove(); // Remove the HTML element from DOM
            this.cssObject = null;
        }

        // Dispose label object and its underlying HTML element
        if (this.labelObject) {
            this.labelObject.parent?.remove(this.labelObject);
            this.labelObject.element?.remove();
            this.labelObject = null;
        }

        // If htmlElement is managed independently and is not cssObject.element (rare for current subclasses)
        // It should be handled here. However, for current known subclasses, cssObject.element is the htmlElement.
        // If this.htmlElement might be different from this.cssObject?.element && this.htmlElement !== this.labelObject?.element) {
        //    this.htmlElement.remove();
        // }
        this.htmlElement = null; // Cleared as it's typically linked to cssObject.element

        this.spaceGraph = null; // Break reference to parent graph to aid garbage collection
        // console.log(`BaseNode ${this.id} disposed resources.`);
    }

    /**
     * Calculates and returns the radius of the node's bounding sphere in world units.
     * This is used by the {@link ForceLayout} engine for collision detection and by the
     * {@link CameraController} (via {@link SpaceGraph#focusOnNode}) for appropriate zooming.
     * Subclasses should override this to provide an accurate radius based on their specific visual representation (mesh size, HTML element dimensions).
     *
     * @returns {number} The radius of the node's bounding sphere.
     *                   Base implementation returns a small default value (`10`).
     */
    getBoundingSphereRadius() {
        return 10;
    } // Default placeholder, subclasses must override for accurate behavior.

    /**
     * Applies or removes a visual style indicating selection.
     * This method is called by {@link SpaceGraph#setSelectedNode}.
     * Subclasses should implement the specific styling changes (e.g., changing color, adding a border or class).
     *
     * @param {boolean} selected - `true` if the node is being selected, `false` if it's being deselected.
     * @example
     * // In an HtmlNodeElement subclass:
     * setSelectedStyle(selected) {
     *   this.htmlElement?.classList.toggle('selected', selected);
     * }
     * // In a ShapeNode subclass:
     * setSelectedStyle(selected) {
     *   if (this.mesh?.material?.emissive) { // Check if material supports emissive color
     *     this.mesh.material.emissive.setHex(selected ? 0x888800 : 0x000000); // Yellowish tint when selected
     *   }
     * }
     */
    setSelectedStyle(selected) {
        /* Base implementation does nothing. Subclasses should override. */
    }

    /**
     * Called by {@link UIManager} when a drag operation starts on this node.
     * The base implementation adds a 'dragging' CSS class to `this.htmlElement` (if it exists)
     * and fixes the node in the {@link ForceLayout} engine to prevent it from being affected by physics during the drag.
     * Subclasses can override for custom drag start behavior, but should typically call `super.startDrag()`.
     */
    startDrag() {
        this.htmlElement?.classList.add('dragging');
        this.spaceGraph?.layoutEngine?.fixNode(this);
    }

    /**
     * Called by {@link UIManager} during a drag operation to update the node's position.
     * The base implementation calls `this.setPosition()` with the new coordinates.
     * Subclasses usually don't need to override this unless they have very specific drag update logic
     * beyond simple position setting.
     *
     * @param {THREE.Vector3} newPosition - The new target position for the node in world space,
     *                                      typically derived from mouse/pointer coordinates.
     */
    drag(newPosition) {
        this.setPosition(newPosition.x, newPosition.y, newPosition.z);
    }

    /**
     * Called by {@link UIManager} when a drag operation ends on this node.
     * The base implementation removes the 'dragging' CSS class from `this.htmlElement` (if it exists),
     * releases the node in the {@link ForceLayout} engine (allowing physics to affect it again),
     * and "kicks" the layout engine to help settle the graph.
     * Subclasses can override for custom drag end behavior, but should typically call `super.endDrag()`.
     */
    endDrag() {
        this.htmlElement?.classList.remove('dragging');
        this.spaceGraph?.layoutEngine?.releaseNode(this);
        this.spaceGraph?.layoutEngine?.kick(); // Re-energize layout after user interaction
    }
}
