<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>SpaceGraph - Inter-Node Communication</title>
    <link href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¬</text></svg>"
          rel="icon">
    <link href="index.css" rel="stylesheet"/>
    <style>
        .data-source-node, .data-receiver-node {
            padding: 15px;
            border-radius: 8px;
            font-family: sans-serif;
            text-align: center;
        }
        .data-source-node {
            background-color: #2980b9; /* Belize Hole */
            color: white;
        }
        .data-source-node button {
            padding: 8px 12px;
            margin-top: 10px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #3498db; /* Peter River */
            color: white;
        }
        .data-receiver-node {
            background-color: #f1c40f; /* Sunflower */
            color: #333;
            min-height: 80px; /* Ensure space for text */
        }
        .receiver-content {
            font-size: 14px;
            margin-top: 5px;
            word-wrap: break-word;
        }
        .node-label-3d { /* Ensure labels are visible if used */
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 2px 5px;
            border-radius: 3px;
        }
    </style>
</head>
<body>

<div id="space">
    <canvas id="webgl-canvas"></canvas>
    <div id="css3d-container"></div>
</div>

<script type="importmap">
    {
        "imports": {
            "three":         "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
            "gsap":          "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
</script>
<script type="module">
    import * as S from './spacegraph.js';

    function init() {
        const container = S.$('#space');
        if (!container) {
            console.error("Initialization Failed: Missing #space container.");
            return;
        }

        try {
            const space = new S.SpaceGraph(container, {});
            window.space = space;

            // Node Type 1: Data Source (HTML based)
            const dataSourceNodeType = {
                getDefaults: (data) => ({
                    label: data.label || 'Data Source',
                    width: 180, height: 100,
                    counter: 0,
                    ports: { outputs: { data_out: { label: 'Data Output', type: 'string' } } }
                }),
                onCreate: (nodeInst, sg) => {
                    nodeInst.htmlElement = document.createElement('div');
                    nodeInst.htmlElement.className = 'data-source-node';
                    nodeInst.htmlElement.innerHTML = `<h4>\${nodeInst.data.label}</h4><p>Counter: <span class="count">0</span></p><button>Send Data</button>`;

                    const button = nodeInst.htmlElement.querySelector('button');
                    const countSpan = nodeInst.htmlElement.querySelector('.count');

                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent UIManager drag
                        nodeInst.data.counter++;
                        countSpan.textContent = nodeInst.data.counter;
                        const message = `Message #${nodeInst.data.counter} from ${nodeInst.id}`;

                        // Emit data via the output port
                        if (nodeInst.data.ports?.outputs?.data_out) {
                            console.log(`${nodeInst.id} emitting 'data_out':`, message);
                            nodeInst.emit('data_out', message);
                        }
                    });

                    nodeInst.customElements = { countSpan }; // For potential external updates if needed
                    return { htmlElement: nodeInst.htmlElement };
                },
                getBoundingSphereRadius: (nodeInst) => Math.max(nodeInst.data.width, nodeInst.data.height) / 2,
            };
            space.registerNodeType('data-source', dataSourceNodeType);

            // Node Type 2: Data Receiver (HTML based)
            const dataReceiverNodeType = {
                getDefaults: (data) => ({
                    label: data.label || 'Data Receiver',
                    width: 220, height: 120,
                    receivedMessage: 'Waiting for data...',
                    ports: { inputs: { data_in: { label: 'Data Input', type: 'string' } } }
                }),
                onCreate: (nodeInst, sg) => {
                    nodeInst.htmlElement = document.createElement('div');
                    nodeInst.htmlElement.className = 'data-receiver-node';
                    nodeInst.htmlElement.innerHTML = `<h4>\${nodeInst.data.label}</h4><div class="receiver-content">\${nodeInst.data.receivedMessage}</div>`;

                    nodeInst.customElements = { contentDiv: nodeInst.htmlElement.querySelector('.receiver-content') };
                    return { htmlElement: nodeInst.htmlElement };
                },
                onDataUpdate: (nodeInst, updatedData) => {
                    // This is the primary way for RegisteredNodes to react to "port" data.
                    // When an edge connects to 'data_in', an external system (or another node's emit via a more complex setup)
                    // would call `space.updateNodeData(receiverNode.id, { data_in: "some value" })`.
                    if (updatedData.data_in !== undefined && nodeInst.customElements?.contentDiv) {
                        nodeInst.data.receivedMessage = updatedData.data_in; // Store it
                        nodeInst.customElements.contentDiv.textContent = updatedData.data_in;
                        console.log(`${nodeInst.id} received via onDataUpdate (data_in):`, updatedData.data_in);
                        // Optional: "consume" data if it's directly on nodeInst.data
                        // if (nodeInst.data.hasOwnProperty('data_in')) delete nodeInst.data.data_in;
                    }
                },
                getBoundingSphereRadius: (nodeInst) => Math.max(nodeInst.data.width, nodeInst.data.height) / 2,
            };
            space.registerNodeType('data-receiver', dataReceiverNodeType);

            // Create instances
            const source1 = space.addNode({ type: 'data-source', id: 'source1', x: -200, y: 0 });
            const receiver1 = space.addNode({ type: 'data-receiver', id: 'receiver1', x: 200, y: 0 });
            const receiver2 = space.addNode({ type: 'data-receiver', id: 'receiver2', x: 200, y: 180, label: 'Receiver B'});

            // Scenario 1: Direct emit/listenTo for RegisteredNode instances
            // This demonstrates that RegisteredNode instances inherit BaseNode's emit/listenTo.
            if (source1 && receiver1) {
                receiver1.listenTo(source1, 'data_out', (payload, senderNode) => {
                    console.log(`${receiver1.id} received directly from ${senderNode.id} via listenTo:`, payload);
                    if (receiver1.customElements?.contentDiv) {
                        receiver1.customElements.contentDiv.innerHTML =
                            `Directly heard from ${senderNode.id}: <br><i>"${payload}"</i>`;
                    }
                });
                console.log(`${receiver1.id} is listening to 'data_out' on ${source1.id}`);
            }

            // Create an edge. This edge signifies a potential data path.
            // The actual data flow for onDataUpdate relies on external calls to space.updateNodeData
            // or a more sophisticated event bus that interprets these edges.
            // For this example, the emit/listenTo above handles direct communication.
            // The edge here is more for visual representation and potential future use by a data flow manager.
            if (source1 && receiver2) {
                 space.addEdge(source1, receiver2, {
                    sourcePort: 'data_out', // from source1
                    targetPort: 'data_in'   // to receiver2
                });
                // To make this edge functional with onDataUpdate for receiver2,
                // source1's button click would need to know about its connections
                // and explicitly call space.updateNodeData for connected nodes.
                // Or, a global event handler could watch for 'data_out' and propagate.
                // For simplicity, we'll manually trigger an update to receiver2's port below.
            }

            // Manually trigger onDataUpdate for receiver2 to simulate data arriving at its 'data_in' port
            setTimeout(() => {
                console.log("Manually pushing data to receiver2's 'data_in' port via updateNodeData...");
                space.updateNodeData(receiver2.id, { data_in: "Simulated message for receiver2's input port." });
            }, 7000);


            // Add a general NoteNode to explain
            space.addNode({
                type: 'note', id: 'info', x: 0, y: -200, width: 400, height: 170,
                content: `<h3>Inter-Node Communication</h3>
                          <p><b>Source Nodes</b> have a button. Clicking it emits a 'data_out' event.</p>
                          <p><b>Receiver1</b> (top-right) uses <code>node.listenTo()</code> to directly catch 'data_out' from Source1.</p>
                          <p><b>Receiver2</b> (bottom-right) has a 'data_in' port. Its <code>onDataUpdate</code> method processes data sent to this key. An edge is drawn, but for <code>onDataUpdate</code> to trigger via this edge, external logic would typically call <code>space.updateNodeData(receiver2.id, { data_in: ... })</code>. A timeout simulates this.</p>
                          <p>Check console for logs.</p>`
            });

            space.layoutEngine.runOnce(100);
            space.centerView();

            const statusEl = S.$('#status-indicator');
            if (statusEl) {
                statusEl.textContent = 'Inter-Node Communication Example Initialized.';
                setTimeout(() => statusEl.classList.add('hidden'), 2000);
            }

        } catch (error) {
            console.error("Inter-node communication example init failed:", error);
            container.innerHTML = `<div style="color:red; padding:20px;">Error: ${error.message}<br><pre>${error.stack}</pre></div>`;
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
</script>
</body>
</html>
