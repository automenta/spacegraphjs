<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>SpaceGraph - RegisteredNode (HTML) Example</title>
    <link href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üõ†Ô∏è</text></svg>"
          rel="icon">
    <link href="index.css" rel="stylesheet"/>
    <style>
        /* Custom styles for the example node */
        .user-profile-node {
            background-color: #2c3e50; /* Dark blue-grey */
            color: #ecf0f1; /* Light grey */
            border-radius: 8px;
            border: 2px solid #3498db; /* Bright blue */
            padding: 10px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            box-sizing: border-box;
            overflow: hidden; /* Ensure content respects node bounds */
        }
        .user-profile-node img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 2px solid #ecf0f1;
        }
        .user-profile-node h3 {
            margin: 0;
            font-size: 16px;
            color: #3498db;
        }
        .user-profile-node p {
            margin: 0;
            font-size: 12px;
            text-align: center;
        }
        .user-profile-node .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #2ecc71; /* Green */
            border: 1px solid #ecf0f1;
        }
        .user-profile-node .status-indicator.offline {
            background-color: #e74c3c; /* Red */
        }
        /* Port styling is handled by default .node-port in index.css */
    </style>
</head>
<body>

<div id="space">
    <canvas id="webgl-canvas"></canvas>
    <div id="css3d-container"></div>
</div>

<script type="importmap">
    {
        "imports": {
            "three":         "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
            "gsap":          "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
</script>
<script type="module">
    import * as S from './spacegraph.js';

    function init() {
        const container = S.$('#space');
        if (!container) {
            console.error("Initialization Failed: Missing required #space container element.");
            return;
        }

        try {
            const space = new S.SpaceGraph(container, {});
            window.space = space; // For debugging

            // 1. Define the TypeDefinition for our HTML-based custom node
            const userProfileNodeDefinition = {
                getDefaults: (initialData) => ({
                    name: initialData?.name || 'User Name',
                    title: initialData?.title || 'User Title',
                    avatarUrl: initialData?.avatarUrl || `https://i.pravatar.cc/60?u=\${initialData?.id || 'default'}`,
                    status: initialData?.status || 'online', // 'online' or 'offline'
                    width: initialData?.width || 180,
                    height: initialData?.height || 150,
                    label: initialData?.label || initialData?.id || 'User Profile',
                    ports: initialData?.ports || {
                        inputs: {
                            status_in: { label: 'Set Status (online/offline)', type: 'string' }
                        },
                        outputs: {
                            name_out: { label: 'User Name', type: 'string' }
                        }
                    }
                }),

                onCreate: (nodeInst, spaceGraph) => {
                    nodeInst.htmlElement = document.createElement('div');
                    nodeInst.htmlElement.className = 'user-profile-node'; // For specific styling
                    // Width and height are applied by RegisteredNode to the CSS3DObject container usually,
                    // but setting it here ensures internal layout is based on these dimensions.
                    nodeInst.htmlElement.style.width = `${nodeInst.data.width}px`;
                    nodeInst.htmlElement.style.height = `${nodeInst.data.height}px`;

                    const avatar = document.createElement('img');
                    avatar.src = nodeInst.data.avatarUrl;
                    avatar.alt = nodeInst.data.name;

                    const nameEl = document.createElement('h3');
                    nameEl.textContent = nodeInst.data.name;

                    const titleEl = document.createElement('p');
                    titleEl.textContent = nodeInst.data.title;

                    const statusIndicator = document.createElement('div');
                    statusIndicator.className = 'status-indicator';
                    if (nodeInst.data.status === 'offline') {
                        statusIndicator.classList.add('offline');
                    }

                    nodeInst.htmlElement.appendChild(avatar);
                    nodeInst.htmlElement.appendChild(nameEl);
                    nodeInst.htmlElement.appendChild(titleEl);
                    nodeInst.htmlElement.appendChild(statusIndicator);

                    // Store elements for onDataUpdate
                    nodeInst.customElements = { avatar, nameEl, titleEl, statusIndicator };

                    // Example: Emit initial name
                    if (nodeInst.data.ports?.outputs?.name_out) {
                        nodeInst.emit('name_out', nodeInst.data.name);
                    }

                    // Prevent SpaceGraph's UIManager from processing pointer events on these elements
                    // to allow text selection or other interactions if needed, and to prevent drag conflicts.
                    [avatar, nameEl, titleEl].forEach(el => {
                        el.addEventListener('pointerdown', e => e.stopPropagation());
                        el.addEventListener('wheel', e => e.stopPropagation()); // Also prevent wheel zoom
                    });

                    return { htmlElement: nodeInst.htmlElement }; // SpaceGraph wraps this in a CSS3DObject
                },

                onDataUpdate: (nodeInst, updatedData) => {
                    let needsRender = false;
                    if (updatedData.name !== undefined && nodeInst.customElements?.nameEl) {
                        if (nodeInst.customElements.nameEl.textContent !== updatedData.name) {
                            nodeInst.customElements.nameEl.textContent = updatedData.name;
                            nodeInst.data.name = updatedData.name; // Update internal data
                            if (nodeInst.data.ports?.outputs?.name_out) { // Emit updated name
                                nodeInst.emit('name_out', updatedData.name);
                            }
                        }
                    }
                    if (updatedData.title !== undefined && nodeInst.customElements?.titleEl) {
                        if (nodeInst.customElements.titleEl.textContent !== updatedData.title) {
                            nodeInst.customElements.titleEl.textContent = updatedData.title;
                            nodeInst.data.title = updatedData.title;
                        }
                    }
                    if (updatedData.avatarUrl !== undefined && nodeInst.customElements?.avatar) {
                         if (nodeInst.customElements.avatar.src !== updatedData.avatarUrl) {
                            nodeInst.customElements.avatar.src = updatedData.avatarUrl;
                            nodeInst.data.avatarUrl = updatedData.avatarUrl;
                        }
                    }
                    if (updatedData.status !== undefined && nodeInst.customElements?.statusIndicator) {
                        if (nodeInst.data.status !== updatedData.status) {
                            nodeInst.data.status = updatedData.status;
                            nodeInst.customElements.statusIndicator.classList.toggle('offline', updatedData.status === 'offline');
                        }
                    }
                    // If an input port 'status_in' receives data:
                    if (updatedData.status_in !== undefined && nodeInst.customElements?.statusIndicator) {
                        const newStatus = String(updatedData.status_in).toLowerCase();
                        if (newStatus === 'online' || newStatus === 'offline') {
                            if (nodeInst.data.status !== newStatus) {
                                nodeInst.data.status = newStatus;
                                nodeInst.customElements.statusIndicator.classList.toggle('offline', newStatus === 'offline');
                                // "Consume" the port data if it's directly modifying nodeInst.data
                                // delete nodeInst.data.status_in; // Or set to null
                            }
                        }
                    }
                },

                // Recommended for layout and camera focusing
                getBoundingSphereRadius: (nodeInst) => {
                    return Math.sqrt(nodeInst.data.width**2 + nodeInst.data.height**2) / 2;
                },

                onDispose: (nodeInst) => {
                    // Clean up custom resources if any (e.g., complex event listeners not on htmlElement itself)
                    nodeInst.customElements = null;
                }
            };

            // 2. Register the new node type
            space.registerNodeType('user-profile', userProfileNodeDefinition);

            // 3. Add instances of the custom node
            const user1 = space.addNode({
                type: 'user-profile',
                id: 'user1',
                x: -200, y: 0,
                label: 'Alice (Profile)', // Overrides default label
                name: 'Alice Wonderland',
                title: 'Chief Curiosity Officer',
                status: 'online'
            });

            const user2 = space.addNode({
                type: 'user-profile',
                id: 'user2',
                x: 200, y: 100,
                name: 'Bob The Builder',
                title: 'Lead Constructionist',
                status: 'offline',
                avatarUrl: 'https://i.pravatar.cc/60?u=bob' // Custom avatar
            });

            const user3 = space.addNode({
                type: 'user-profile',
                id: 'user3',
                x: 0, y: -150,
                name: 'Charlie Brown',
                title: 'Professional Sigh-er',
                status: 'online',
                avatarUrl: 'https://i.pravatar.cc/60?u=charlie'
            });

            // Example: Connect output port (name_out) of user1 to input port (status_in) of user2
            // This is a conceptual connection; actual data flow would need a listener or intermediary.
            // For this example, we'll mainly show the ports visually.
            // True data flow will be in the inter-node communication example.
            if (user1 && user2) {
                 space.addEdge(user1, user2, {
                    sourcePort: 'name_out', // From user1's definition
                    targetPort: 'status_in'  // To user2's definition
                 });
            }
             if (user1 && user3) {
                 space.addEdge(user1, user3); // A generic node-to-node edge
            }


            // Add a regular NoteNode to show interaction or receive data
            const displayNode = space.addNode({
                type: 'note',
                id: 'display-note',
                x: 0, y: 200,
                width: 250, height: 100,
                content: 'Waiting for data from user profiles...'
            });

            // Listen to user1's name_out port
            if (user1 && displayNode) {
                const displayNodeInstance = space.getNodeById('display-note');
                user1.listenTo(displayNodeInstance, 'name_out', (namePayload, senderNode) => {
                    // This is backwards. displayNodeInstance should listen TO user1.
                });

                // Corrected: displayNode listens to user1's 'name_out' event
                displayNodeInstance.listenTo(user1, 'name_out', (namePayload, senderNode) => {
                    console.log(`DisplayNode received name from ${senderNode.id}: ${namePayload}`);
                    displayNodeInstance.data.content = `<b>${senderNode.data.name}</b> (${senderNode.data.title}) just emitted their name.`;
                    const contentDiv = displayNodeInstance.htmlElement?.querySelector('.node-content');
                    if(contentDiv) contentDiv.innerHTML = displayNodeInstance.data.content;
                });
                 console.log(`Node ${displayNodeInstance.id} is now listening to 'name_out' events from ${user1.id}`);
            }

            // Example of updating a node's data which should trigger onDataUpdate
            setTimeout(() => {
                if (user2) {
                    console.log("Updating user2's status via space.updateNodeData()...");
                    space.updateNodeData(user2.id, { status: 'online', title: 'Chief Problem Solver' });
                    // This will also trigger onDataUpdate for 'status', which will update the visual.
                    // To send to a port:
                    // space.updateNodeData(user2.id, { status_in: 'online' });
                }
            }, 5000);


            space.layoutEngine.runOnce(150);
            space.centerView();

            const statusEl = S.$('#status-indicator');
            if (statusEl) {
                statusEl.textContent = 'RegisteredNode (HTML) Example Initialized.';
                setTimeout(() => statusEl.classList.add('hidden'), 2000);
            }

        } catch (error) {
            console.error("RegisteredNode HTML Example Initialization Failed:", error);
            container.innerHTML = `<div style="color:red; padding:20px;">Error: ${error.message}<br><pre>${error.stack}</pre></div>`;
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
</script>
</body>
</html>
