<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>SpaceGraph - RegisteredNode (WebGL) Example</title>
    <link href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ¨</text></svg>"
          rel="icon">
    <link href="index.css" rel="stylesheet"/>
    <style>
        /* No specific styles needed for the node itself, as it's WebGL. */
        /* Label styling is handled by .node-label-3d in index.css */
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(40,40,60,0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls button {
            margin: 5px;
            padding: 8px;
        }
    </style>
</head>
<body>

<div id="space">
    <canvas id="webgl-canvas"></canvas>
    <div id="css3d-container"></div>
</div>

<div id="controls">
    <button id="btn-change-color">Change Crystal Color</button>
    <button id="btn-toggle-wireframe">Toggle Wireframe</button>
</div>

<script type="importmap">
    {
        "imports": {
            "three":         "https://cdn.jsdelivr.net/npm/three@0.166.1/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.166.1/examples/jsm/",
            "gsap":          "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
        }
    }
</script>
<script type="module">
    import * as S from './spacegraph.js';
    import * as THREE from 'three'; // Import THREE directly for geometry/material access

    function init() {
        const container = S.$('#space');
        if (!container) {
            console.error("Initialization Failed: Missing required #space container element.");
            return;
        }

        try {
            const space = new S.SpaceGraph(container, {});
            window.space = space; // For debugging

            // 1. Define the TypeDefinition for our WebGL-based custom node
            const crystalNodeDefinition = {
                getDefaults: (initialData) => ({
                    size: initialData?.size || 50,
                    color: initialData?.color || 0x00ffdd, // Default teal
                    wireframe: initialData?.wireframe || false,
                    label: initialData?.label || initialData?.id || 'Crystal Node',
                    // No explicit ports in this example, but could be added
                }),

                onCreate: (nodeInst, spaceGraph) => {
                    // Geometry: Icosahedron for a crystal-like shape
                    const geometry = new THREE.IcosahedronGeometry(nodeInst.data.size / 2, 0); // radius, detail

                    // Material
                    const material = new THREE.MeshStandardMaterial({
                        color: nodeInst.data.color,
                        wireframe: nodeInst.data.wireframe,
                        roughness: 0.3,
                        metalness: 0.6,
                        flatShading: true // Gives a faceted look
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.userData.nodeId = nodeInst.id; // Important for UIManager

                    // Label for the node
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'node-label-3d'; // Use default styling
                    labelDiv.textContent = nodeInst.data.label;
                    const labelObject = new spaceGraph.constructor.THREE.CSS3DObject(labelDiv);

                    nodeInst.customElements = { material }; // Store material for updates

                    return { mesh, labelObject };
                },

                onDataUpdate: (nodeInst, updatedData) => {
                    const material = nodeInst.customElements?.material;
                    if (!material) return;

                    if (updatedData.color !== undefined) {
                        material.color.setHex(updatedData.color);
                        nodeInst.data.color = updatedData.color; // Update internal data
                    }
                    if (updatedData.wireframe !== undefined) {
                        material.wireframe = updatedData.wireframe;
                        nodeInst.data.wireframe = updatedData.wireframe;
                    }
                    if (updatedData.size !== undefined) {
                        // Recreating geometry on size change is complex for this example.
                        // A simpler approach for mesh nodes is to use mesh.scale.
                        // This requires the original geometry to be based on a unit size,
                        // or calculate scale based on current vs new size.
                        // For now, we'll assume size is mostly for initial creation or requires manual scaling.
                        // If nodeInst.mesh is accessible and geometry is simple:
                        if (nodeInst.mesh) {
                            const oldSize = nodeInst.data.size || 50;
                            const newSize = updatedData.size;
                            const scale = newSize / oldSize;
                            nodeInst.mesh.scale.multiplyScalar(scale);
                            nodeInst.data.size = newSize; // Update internal data
                        }
                    }
                    if (updatedData.label !== undefined && nodeInst.labelObject?.element) {
                         nodeInst.labelObject.element.textContent = updatedData.label;
                         nodeInst.data.label = updatedData.label;
                    }
                },

                getBoundingSphereRadius: (nodeInst) => {
                    // Based on IcosahedronGeometry radius
                    return (nodeInst.data.size / 2) * 1.1; // A little padding
                },

                onSetSelectedStyle: (nodeInst, isSelected) => {
                    // Example: make it slightly emissive when selected
                    if (nodeInst.mesh?.material) {
                        nodeInst.mesh.material.emissive?.setHex(isSelected ? 0x333333 : 0x000000);
                    }
                    if (nodeInst.labelObject?.element) {
                        nodeInst.labelObject.element.classList.toggle('selected', isSelected);
                    }
                },

                onDispose: (nodeInst) => {
                    // Geometry and material are part of the mesh, which SpaceGraph handles.
                    // If we created separate geometries/materials not assigned to mesh, dispose here.
                    nodeInst.customElements = null;
                }
            };

            // 2. Register the new node type
            space.registerNodeType('crystal-node', crystalNodeDefinition);

            // 3. Add instances of the custom node
            const crystal1 = space.addNode({
                type: 'crystal-node',
                id: 'crystal1',
                x: -150, y: 50,
                label: 'Aqua Crystal',
                color: 0x00f0ff,
                size: 60
            });

            const crystal2 = space.addNode({
                type: 'crystal-node',
                id: 'crystal2',
                x: 100, y: -80, z: 30,
                label: 'Ruby Crystal',
                color: 0xff003c,
                size: 40,
                wireframe: true
            });

            const crystal3 = space.addNode({
                type: 'crystal-node',
                id: 'crystal3',
                x: 50, y: 150, z: -20,
                label: 'Emerald Crystal',
                color: 0x00ff55,
                size: 75
            });

            // Add some regular nodes to connect to
            const note1 = space.addNode({ type: 'note', id: 'note-link1', x: 0, y: 0, content: 'Central Note'});

            space.addEdge(note1, crystal1);
            space.addEdge(note1, crystal2);
            space.addEdge(crystal1, crystal3);
            space.addEdge(crystal2, crystal3, {constraintParams: {idealLength: 250}});

            // Setup UI controls for dynamic updates
            const colors = [0xffaa00, 0x00aaff, 0xaa00ff, 0x00ffaa];
            let colorIndex = 0;
            S.$('#btn-change-color').addEventListener('click', () => {
                const newColor = colors[colorIndex % colors.length];
                colorIndex++;
                // Update all crystal nodes
                space.nodes.forEach(node => {
                    if (node.data.type === 'crystal-node') {
                        space.updateNodeData(node.id, { color: newColor });
                    }
                });
            });

            S.$('#btn-toggle-wireframe').addEventListener('click', () => {
                // Toggle wireframe for crystal2
                const c2 = space.getNodeById('crystal2');
                if (c2) {
                    space.updateNodeData(c2.id, { wireframe: !c2.data.wireframe });
                }
            });

            space.layoutEngine.runOnce(150);
            space.centerView();

            const statusEl = S.$('#status-indicator');
            if (statusEl) {
                statusEl.textContent = 'RegisteredNode (WebGL) Example Initialized.';
                setTimeout(() => statusEl.classList.add('hidden'), 2000);
            }

        } catch (error) {
            console.error("RegisteredNode WebGL Example Initialization Failed:", error);
            container.innerHTML = `<div style="color:red; padding:20px;">Error: ${error.message}<br><pre>${error.stack}</pre></div>`;
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
</script>
</body>
</html>
